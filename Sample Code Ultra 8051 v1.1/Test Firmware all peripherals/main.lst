                              1 ;--------------------------------------------------------
                              2 ; File Created by SDCC : free open source ANSI-C Compiler
                              3 ; Version 3.0.1 #6083 (Dec 17 2010) (MINGW32)
                              4 ; This file was generated Sat Mar 14 18:59:42 2015
                              5 ;--------------------------------------------------------
                              6 	.module main
                              7 	.optsdcc -mmcs51 --model-small
                              8 	
                              9 ;--------------------------------------------------------
                             10 ; Public variables in this module
                             11 ;--------------------------------------------------------
                             12 	.globl _main
                             13 	.globl _T2CON_7
                             14 	.globl _T2CON_6
                             15 	.globl _T2CON_5
                             16 	.globl _T2CON_4
                             17 	.globl _T2CON_3
                             18 	.globl _T2CON_2
                             19 	.globl _T2CON_1
                             20 	.globl _T2CON_0
                             21 	.globl _RI
                             22 	.globl _TI
                             23 	.globl _RB8
                             24 	.globl _TB8
                             25 	.globl _REN
                             26 	.globl _SM2
                             27 	.globl _SM1
                             28 	.globl _SM0
                             29 	.globl _P1_7
                             30 	.globl _P1_6
                             31 	.globl _P1_5
                             32 	.globl _P1_4
                             33 	.globl _P1_3
                             34 	.globl _P1_2
                             35 	.globl _P1_1
                             36 	.globl _P1_0
                             37 	.globl _RXD
                             38 	.globl _TXD
                             39 	.globl _INT0
                             40 	.globl _INT1
                             41 	.globl _T0
                             42 	.globl _T1
                             43 	.globl _WR
                             44 	.globl _RD
                             45 	.globl _PX0
                             46 	.globl _PT0
                             47 	.globl _PX1
                             48 	.globl _PT1
                             49 	.globl _PS
                             50 	.globl _EX0
                             51 	.globl _ET0
                             52 	.globl _EX1
                             53 	.globl _ET1
                             54 	.globl _ES
                             55 	.globl _EA
                             56 	.globl _IT0
                             57 	.globl _IE0
                             58 	.globl _IT1
                             59 	.globl _IE1
                             60 	.globl _TR0
                             61 	.globl _TF0
                             62 	.globl _TR1
                             63 	.globl _TF1
                             64 	.globl _P
                             65 	.globl _OV
                             66 	.globl _RS0
                             67 	.globl _RS1
                             68 	.globl _F0
                             69 	.globl _AC
                             70 	.globl _CY
                             71 	.globl _FL
                             72 	.globl _TF2
                             73 	.globl _EXF2
                             74 	.globl _RCLK
                             75 	.globl _TCLK
                             76 	.globl _EXEN2
                             77 	.globl _TR2
                             78 	.globl _C_T2
                             79 	.globl _CP_RL2
                             80 	.globl _PT2
                             81 	.globl _P3_7
                             82 	.globl _P3_6
                             83 	.globl _P3_5
                             84 	.globl _P3_4
                             85 	.globl _P3_3
                             86 	.globl _P3_2
                             87 	.globl _P3_1
                             88 	.globl _P3_0
                             89 	.globl _ET2
                             90 	.globl _P2_7
                             91 	.globl _P2_6
                             92 	.globl _P2_5
                             93 	.globl _P2_4
                             94 	.globl _P2_3
                             95 	.globl _P2_2
                             96 	.globl _P2_1
                             97 	.globl _P2_0
                             98 	.globl _T2EX
                             99 	.globl _T2
                            100 	.globl _P0_7
                            101 	.globl _P0_6
                            102 	.globl _P0_5
                            103 	.globl _P0_4
                            104 	.globl _P0_3
                            105 	.globl _P0_2
                            106 	.globl _P0_1
                            107 	.globl _P0_0
                            108 	.globl _RCAP2L
                            109 	.globl _RCAP2H
                            110 	.globl _T2CON
                            111 	.globl _SBUF
                            112 	.globl _SCON
                            113 	.globl _IP
                            114 	.globl _IE
                            115 	.globl _AUXR
                            116 	.globl _TH1
                            117 	.globl _TH0
                            118 	.globl _TL1
                            119 	.globl _TL0
                            120 	.globl _TMOD
                            121 	.globl _TCON
                            122 	.globl _PCON
                            123 	.globl _DPH
                            124 	.globl _DPL
                            125 	.globl _SP
                            126 	.globl _B
                            127 	.globl _ACC
                            128 	.globl _PSW
                            129 	.globl _P3
                            130 	.globl _P2
                            131 	.globl _P1
                            132 	.globl _P0
                            133 	.globl _A
                            134 	.globl _TH2
                            135 	.globl _TL2
                            136 	.globl _T2MOD
                            137 	.globl _mm_option
                            138 	.globl _ARR_LcdLineNumAddress_U8
                            139 	.globl _STK_LCDConfig
                            140 	.globl _VAR_LcdTrackCursorPos_U8
                            141 	.globl _VAR_LcdTrackLineNum_U8
                            142 	.globl _UART_Init
                            143 	.globl _UART_SetBaudRate
                            144 	.globl _UART_RxChar
                            145 	.globl _UART_TxChar
                            146 	.globl _UART_TxString
                            147 	.globl _UART_TxDecimalNumber
                            148 	.globl _UART_TxHexNumber
                            149 	.globl _UART_Printf
                            150 	.globl _RTC_Init
                            151 	.globl _RTC_SetTime
                            152 	.globl _RTC_SetDate
                            153 	.globl _RTC_GetTime
                            154 	.globl _RTC_GetDate
                            155 	.globl _I2C_Init
                            156 	.globl _I2C_Start
                            157 	.globl _I2C_Stop
                            158 	.globl _I2C_Write
                            159 	.globl _I2C_Read
                            160 	.globl _LCD_Init
                            161 	.globl _LCD_Clear
                            162 	.globl _LCD_GoToLine
                            163 	.globl _LCD_GoToNextLine
                            164 	.globl _LCD_CmdWrite
                            165 	.globl _LCD_DisplayChar
                            166 	.globl _LCD_DisplayString
                            167 	.globl _DELAY_us
                            168 	.globl _DELAY_ms
                            169 	.globl _DELAY_sec
                            170 	.globl _ADC_Init
                            171 	.globl _ADC_GetAdcValue
                            172 	.globl _KEYPAD_Init
                            173 	.globl _KEYPAD_WaitForKeyRelease
                            174 	.globl _KEYPAD_WaitForKeyPress
                            175 	.globl _KEYPAD_GetKey
                            176 	.globl _EEPROM_WriteByte
                            177 	.globl _EEPROM_ReadByte
                            178 	.globl _EEPROM_WriteString
                            179 	.globl _EEPROM_ReadString
                            180 	.globl _gpio_test
                            181 	.globl _LCD_test
                            182 	.globl _seg_test
                            183 	.globl _rtc_test
                            184 	.globl _eeprom_test
                            185 	.globl _adc_test
                            186 	.globl _keypad_test
                            187 ;--------------------------------------------------------
                            188 ; special function registers
                            189 ;--------------------------------------------------------
                            190 	.area RSEG    (ABS,DATA)
   0000                     191 	.org 0x0000
                    00C9    192 _T2MOD	=	0x00c9
                    00CC    193 _TL2	=	0x00cc
                    00CD    194 _TH2	=	0x00cd
                    00E0    195 _A	=	0x00e0
                    0080    196 _P0	=	0x0080
                    0090    197 _P1	=	0x0090
                    00A0    198 _P2	=	0x00a0
                    00B0    199 _P3	=	0x00b0
                    00D0    200 _PSW	=	0x00d0
                    00E0    201 _ACC	=	0x00e0
                    00F0    202 _B	=	0x00f0
                    0081    203 _SP	=	0x0081
                    0082    204 _DPL	=	0x0082
                    0083    205 _DPH	=	0x0083
                    0087    206 _PCON	=	0x0087
                    0088    207 _TCON	=	0x0088
                    0089    208 _TMOD	=	0x0089
                    008A    209 _TL0	=	0x008a
                    008B    210 _TL1	=	0x008b
                    008C    211 _TH0	=	0x008c
                    008D    212 _TH1	=	0x008d
                    008E    213 _AUXR	=	0x008e
                    00A8    214 _IE	=	0x00a8
                    00B8    215 _IP	=	0x00b8
                    0098    216 _SCON	=	0x0098
                    0099    217 _SBUF	=	0x0099
                    00C8    218 _T2CON	=	0x00c8
                    00CB    219 _RCAP2H	=	0x00cb
                    00CA    220 _RCAP2L	=	0x00ca
                            221 ;--------------------------------------------------------
                            222 ; special function bits
                            223 ;--------------------------------------------------------
                            224 	.area RSEG    (ABS,DATA)
   0000                     225 	.org 0x0000
                    0080    226 _P0_0	=	0x0080
                    0081    227 _P0_1	=	0x0081
                    0082    228 _P0_2	=	0x0082
                    0083    229 _P0_3	=	0x0083
                    0084    230 _P0_4	=	0x0084
                    0085    231 _P0_5	=	0x0085
                    0086    232 _P0_6	=	0x0086
                    0087    233 _P0_7	=	0x0087
                    0090    234 _T2	=	0x0090
                    0091    235 _T2EX	=	0x0091
                    00A0    236 _P2_0	=	0x00a0
                    00A1    237 _P2_1	=	0x00a1
                    00A2    238 _P2_2	=	0x00a2
                    00A3    239 _P2_3	=	0x00a3
                    00A4    240 _P2_4	=	0x00a4
                    00A5    241 _P2_5	=	0x00a5
                    00A6    242 _P2_6	=	0x00a6
                    00A7    243 _P2_7	=	0x00a7
                    00AD    244 _ET2	=	0x00ad
                    00B0    245 _P3_0	=	0x00b0
                    00B1    246 _P3_1	=	0x00b1
                    00B2    247 _P3_2	=	0x00b2
                    00B3    248 _P3_3	=	0x00b3
                    00B4    249 _P3_4	=	0x00b4
                    00B5    250 _P3_5	=	0x00b5
                    00B6    251 _P3_6	=	0x00b6
                    00B7    252 _P3_7	=	0x00b7
                    00BD    253 _PT2	=	0x00bd
                    00C8    254 _CP_RL2	=	0x00c8
                    00C9    255 _C_T2	=	0x00c9
                    00CA    256 _TR2	=	0x00ca
                    00CB    257 _EXEN2	=	0x00cb
                    00CC    258 _TCLK	=	0x00cc
                    00CD    259 _RCLK	=	0x00cd
                    00CE    260 _EXF2	=	0x00ce
                    00CF    261 _TF2	=	0x00cf
                    00D1    262 _FL	=	0x00d1
                    00D7    263 _CY	=	0x00d7
                    00D6    264 _AC	=	0x00d6
                    00D5    265 _F0	=	0x00d5
                    00D4    266 _RS1	=	0x00d4
                    00D3    267 _RS0	=	0x00d3
                    00D2    268 _OV	=	0x00d2
                    00D0    269 _P	=	0x00d0
                    008F    270 _TF1	=	0x008f
                    008E    271 _TR1	=	0x008e
                    008D    272 _TF0	=	0x008d
                    008C    273 _TR0	=	0x008c
                    008B    274 _IE1	=	0x008b
                    008A    275 _IT1	=	0x008a
                    0089    276 _IE0	=	0x0089
                    0088    277 _IT0	=	0x0088
                    00AF    278 _EA	=	0x00af
                    00AC    279 _ES	=	0x00ac
                    00AB    280 _ET1	=	0x00ab
                    00AA    281 _EX1	=	0x00aa
                    00A9    282 _ET0	=	0x00a9
                    00A8    283 _EX0	=	0x00a8
                    00BC    284 _PS	=	0x00bc
                    00BB    285 _PT1	=	0x00bb
                    00BA    286 _PX1	=	0x00ba
                    00B9    287 _PT0	=	0x00b9
                    00B8    288 _PX0	=	0x00b8
                    00B7    289 _RD	=	0x00b7
                    00B6    290 _WR	=	0x00b6
                    00B5    291 _T1	=	0x00b5
                    00B4    292 _T0	=	0x00b4
                    00B3    293 _INT1	=	0x00b3
                    00B2    294 _INT0	=	0x00b2
                    00B1    295 _TXD	=	0x00b1
                    00B0    296 _RXD	=	0x00b0
                    0090    297 _P1_0	=	0x0090
                    0091    298 _P1_1	=	0x0091
                    0092    299 _P1_2	=	0x0092
                    0093    300 _P1_3	=	0x0093
                    0094    301 _P1_4	=	0x0094
                    0095    302 _P1_5	=	0x0095
                    0096    303 _P1_6	=	0x0096
                    0097    304 _P1_7	=	0x0097
                    009F    305 _SM0	=	0x009f
                    009E    306 _SM1	=	0x009e
                    009D    307 _SM2	=	0x009d
                    009C    308 _REN	=	0x009c
                    009B    309 _TB8	=	0x009b
                    009A    310 _RB8	=	0x009a
                    0099    311 _TI	=	0x0099
                    0098    312 _RI	=	0x0098
                    00C8    313 _T2CON_0	=	0x00c8
                    00C9    314 _T2CON_1	=	0x00c9
                    00CA    315 _T2CON_2	=	0x00ca
                    00CB    316 _T2CON_3	=	0x00cb
                    00CC    317 _T2CON_4	=	0x00cc
                    00CD    318 _T2CON_5	=	0x00cd
                    00CE    319 _T2CON_6	=	0x00ce
                    00CF    320 _T2CON_7	=	0x00cf
                            321 ;--------------------------------------------------------
                            322 ; overlayable register banks
                            323 ;--------------------------------------------------------
                            324 	.area REG_BANK_0	(REL,OVR,DATA)
   0000                     325 	.ds 8
                            326 ;--------------------------------------------------------
                            327 ; internal ram data
                            328 ;--------------------------------------------------------
                            329 	.area DSEG    (DATA)
   0000                     330 _VAR_LcdTrackLineNum_U8::
   0000                     331 	.ds 1
   0001                     332 _VAR_LcdTrackCursorPos_U8::
   0001                     333 	.ds 1
   0002                     334 _STK_LCDConfig::
   0002                     335 	.ds 3
   0005                     336 _ARR_LcdLineNumAddress_U8::
   0005                     337 	.ds 5
   000A                     338 _mm_option::
   000A                     339 	.ds 1
                            340 ;--------------------------------------------------------
                            341 ; overlayable items in internal ram 
                            342 ;--------------------------------------------------------
                            343 	.area OSEG    (OVR,DATA)
                            344 ;--------------------------------------------------------
                            345 ; Stack segment in internal ram 
                            346 ;--------------------------------------------------------
                            347 	.area	SSEG	(DATA)
   0000                     348 __start__stack:
   0000                     349 	.ds	1
                            350 
                            351 ;--------------------------------------------------------
                            352 ; indirectly addressable internal ram data
                            353 ;--------------------------------------------------------
                            354 	.area ISEG    (DATA)
                            355 ;--------------------------------------------------------
                            356 ; absolute internal ram data
                            357 ;--------------------------------------------------------
                            358 	.area IABS    (ABS,DATA)
                            359 	.area IABS    (ABS,DATA)
                            360 ;--------------------------------------------------------
                            361 ; bit data
                            362 ;--------------------------------------------------------
                            363 	.area BSEG    (BIT)
                            364 ;--------------------------------------------------------
                            365 ; paged external ram data
                            366 ;--------------------------------------------------------
                            367 	.area PSEG    (PAG,XDATA)
                            368 ;--------------------------------------------------------
                            369 ; external ram data
                            370 ;--------------------------------------------------------
                            371 	.area XSEG    (XDATA)
                            372 ;--------------------------------------------------------
                            373 ; absolute external ram data
                            374 ;--------------------------------------------------------
                            375 	.area XABS    (ABS,XDATA)
                            376 ;--------------------------------------------------------
                            377 ; external initialized ram data
                            378 ;--------------------------------------------------------
                            379 	.area XISEG   (XDATA)
                            380 	.area HOME    (CODE)
                            381 	.area GSINIT0 (CODE)
                            382 	.area GSINIT1 (CODE)
                            383 	.area GSINIT2 (CODE)
                            384 	.area GSINIT3 (CODE)
                            385 	.area GSINIT4 (CODE)
                            386 	.area GSINIT5 (CODE)
                            387 	.area GSINIT  (CODE)
                            388 	.area GSFINAL (CODE)
                            389 	.area CSEG    (CODE)
                            390 ;--------------------------------------------------------
                            391 ; interrupt vector 
                            392 ;--------------------------------------------------------
                            393 	.area HOME    (CODE)
   0000                     394 __interrupt_vect:
   0000 02s00r00            395 	ljmp	__sdcc_gsinit_startup
                            396 ;--------------------------------------------------------
                            397 ; global & static initialisations
                            398 ;--------------------------------------------------------
                            399 	.area HOME    (CODE)
                            400 	.area GSINIT  (CODE)
                            401 	.area GSFINAL (CODE)
                            402 	.area GSINIT  (CODE)
                            403 	.globl __sdcc_gsinit_startup
                            404 	.globl __sdcc_program_startup
                            405 	.globl __start__stack
                            406 	.globl __mcs51_genXINIT
                            407 	.globl __mcs51_genXRAMCLEAR
                            408 	.globl __mcs51_genRAMCLEAR
                            409 ;	D:\Workspace\MIDE\firmware\/lcd.c:79: uint8_t ARR_LcdLineNumAddress_U8[]={0x80,0x80,0xc0,0x90,0xd0};
   0000 75*05 80            410 	mov	_ARR_LcdLineNumAddress_U8,#0x80
   0003 75*06 80            411 	mov	(_ARR_LcdLineNumAddress_U8 + 0x0001),#0x80
   0006 75*07 C0            412 	mov	(_ARR_LcdLineNumAddress_U8 + 0x0002),#0xC0
   0009 75*08 90            413 	mov	(_ARR_LcdLineNumAddress_U8 + 0x0003),#0x90
   000C 75*09 D0            414 	mov	(_ARR_LcdLineNumAddress_U8 + 0x0004),#0xD0
                            415 	.area GSFINAL (CODE)
   0000 02s00r03            416 	ljmp	__sdcc_program_startup
                            417 ;--------------------------------------------------------
                            418 ; Home
                            419 ;--------------------------------------------------------
                            420 	.area HOME    (CODE)
                            421 	.area HOME    (CODE)
   0003                     422 __sdcc_program_startup:
   0003 12s10r07            423 	lcall	_main
                            424 ;	return from main will lock up
   0006 80 FE               425 	sjmp .
                            426 ;--------------------------------------------------------
                            427 ; code
                            428 ;--------------------------------------------------------
                            429 	.area CSEG    (CODE)
                            430 ;------------------------------------------------------------
                            431 ;Allocation info for local variables in function 'UART_Init'
                            432 ;------------------------------------------------------------
                            433 ;var_baudRate_u32          Allocated to registers r2 r3 r4 r5 
                            434 ;------------------------------------------------------------
                            435 ;	D:\Workspace\MIDE\firmware\/uart.c:59: void UART_Init(uint32_t var_baudRate_u32)
                            436 ;	-----------------------------------------
                            437 ;	 function UART_Init
                            438 ;	-----------------------------------------
   0000                     439 _UART_Init:
                    0002    440 	ar2 = 0x02
                    0003    441 	ar3 = 0x03
                    0004    442 	ar4 = 0x04
                    0005    443 	ar5 = 0x05
                    0006    444 	ar6 = 0x06
                    0007    445 	ar7 = 0x07
                    0000    446 	ar0 = 0x00
                    0001    447 	ar1 = 0x01
   0000 AA 82               448 	mov	r2,dpl
   0002 AB 83               449 	mov	r3,dph
   0004 AC F0               450 	mov	r4,b
   0006 FD                  451 	mov	r5,a
                            452 ;	D:\Workspace\MIDE\firmware\/uart.c:61: TMOD |= 0x20; //Timer1 in Mode2.
   0007 43 89 20            453 	orl	_TMOD,#0x20
                            454 ;	D:\Workspace\MIDE\firmware\/uart.c:62: SCON=0x50;    // Asynchronous mode, 8-bit data and 1-stop bit
   000A 75 98 50            455 	mov	_SCON,#0x50
                            456 ;	D:\Workspace\MIDE\firmware\/uart.c:63: TR1=1;        //Turn ON the timer for Baud rate generation
   000D D2 8E               457 	setb	_TR1
                            458 ;	D:\Workspace\MIDE\firmware\/uart.c:64: UART_SetBaudRate(var_baudRate_u32);
   000F 8A 82               459 	mov	dpl,r2
   0011 8B 83               460 	mov	dph,r3
   0013 8C F0               461 	mov	b,r4
   0015 ED                  462 	mov	a,r5
   0016 02s00r19            463 	ljmp	_UART_SetBaudRate
                            464 ;------------------------------------------------------------
                            465 ;Allocation info for local variables in function 'UART_SetBaudRate'
                            466 ;------------------------------------------------------------
                            467 ;var_baudRate_u32          Allocated to registers r2 r3 r4 r5 
                            468 ;RegValue                  Allocated to registers r2 
                            469 ;------------------------------------------------------------
                            470 ;	D:\Workspace\MIDE\firmware\/uart.c:84: void UART_SetBaudRate(uint32_t var_baudRate_u32)
                            471 ;	-----------------------------------------
                            472 ;	 function UART_SetBaudRate
                            473 ;	-----------------------------------------
   0019                     474 _UART_SetBaudRate:
   0019 AA 82               475 	mov	r2,dpl
   001B AB 83               476 	mov	r3,dph
   001D AC F0               477 	mov	r4,b
   001F FD                  478 	mov	r5,a
                            479 ;	D:\Workspace\MIDE\firmware\/uart.c:88: if((var_baudRate_u32 >= C_MinBaudRate_U32) && (var_baudRate_u32<=C_MaxBaudRate_U32))
   0020 C3                  480 	clr	c
   0021 EA                  481 	mov	a,r2
   0022 94 60               482 	subb	a,#0x60
   0024 EB                  483 	mov	a,r3
   0025 94 09               484 	subb	a,#0x09
   0027 EC                  485 	mov	a,r4
   0028 94 00               486 	subb	a,#0x00
   002A ED                  487 	mov	a,r5
   002B 94 00               488 	subb	a,#0x00
   002D 40 4F               489 	jc	00102$
   002F E4                  490 	clr	a
   0030 9A                  491 	subb	a,r2
   0031 74 C2               492 	mov	a,#0xC2
   0033 9B                  493 	subb	a,r3
   0034 74 01               494 	mov	a,#0x01
   0036 9C                  495 	subb	a,r4
   0037 E4                  496 	clr	a
   0038 9D                  497 	subb	a,r5
   0039 40 43               498 	jc	00102$
                            499 ;	D:\Workspace\MIDE\firmware\/uart.c:92: RegValue = M_GetBaudRateGeneratorValue(var_baudRate_u32);
   003B C0 02               500 	push	ar2
   003D C0 03               501 	push	ar3
   003F C0 04               502 	push	ar4
   0041 C0 05               503 	push	ar5
   0043 90 01 80            504 	mov	dptr,#0x0180
   0046 E4                  505 	clr	a
   0047 F5 F0               506 	mov	b,a
   0049 12s00r00            507 	lcall	__mullong
   004C AA 82               508 	mov	r2,dpl
   004E AB 83               509 	mov	r3,dph
   0050 AC F0               510 	mov	r4,b
   0052 FD                  511 	mov	r5,a
   0053 E5 81               512 	mov	a,sp
   0055 24 FC               513 	add	a,#0xfc
   0057 F5 81               514 	mov	sp,a
   0059 C0 02               515 	push	ar2
   005B C0 03               516 	push	ar3
   005D C0 04               517 	push	ar4
   005F C0 05               518 	push	ar5
   0061 90 C0 00            519 	mov	dptr,#0xC000
   0064 75 F0 A8            520 	mov	b,#0xA8
   0067 E4                  521 	clr	a
   0068 12s00r00            522 	lcall	__divulong
   006B AA 82               523 	mov	r2,dpl
   006D AB 83               524 	mov	r3,dph
   006F AC F0               525 	mov	r4,b
   0071 FD                  526 	mov	r5,a
   0072 E5 81               527 	mov	a,sp
   0074 24 FC               528 	add	a,#0xfc
   0076 F5 81               529 	mov	sp,a
   0078 C3                  530 	clr	c
   0079 E4                  531 	clr	a
   007A 9A                  532 	subb	a,r2
   007B FA                  533 	mov	r2,a
   007C 80 02               534 	sjmp	00103$
   007E                     535 00102$:
                            536 ;	D:\Workspace\MIDE\firmware\/uart.c:97: RegValue = M_GetBaudRateGeneratorValue(9600);
   007E 7A 5D               537 	mov	r2,#0x5D
   0080                     538 00103$:
                            539 ;	D:\Workspace\MIDE\firmware\/uart.c:100: TH1 = RegValue; 
   0080 8A 8D               540 	mov	_TH1,r2
   0082 22                  541 	ret
                            542 ;------------------------------------------------------------
                            543 ;Allocation info for local variables in function 'UART_RxChar'
                            544 ;------------------------------------------------------------
                            545 ;------------------------------------------------------------
                            546 ;	D:\Workspace\MIDE\firmware\/uart.c:116: char UART_RxChar()
                            547 ;	-----------------------------------------
                            548 ;	 function UART_RxChar
                            549 ;	-----------------------------------------
   0083                     550 _UART_RxChar:
                            551 ;	D:\Workspace\MIDE\firmware\/uart.c:118: while(RI==0);	  // Wait till the data is received
   0083                     552 00101$:
                            553 ;	D:\Workspace\MIDE\firmware\/uart.c:119: RI=0;             // Clear Receive Interrupt Flag for next cycle
   0083 10 98 02            554 	jbc	_RI,00108$
   0086 80 FB               555 	sjmp	00101$
   0088                     556 00108$:
                            557 ;	D:\Workspace\MIDE\firmware\/uart.c:121: return(SBUF);	  // return the received char
   0088 85 99 82            558 	mov	dpl,_SBUF
   008B 22                  559 	ret
                            560 ;------------------------------------------------------------
                            561 ;Allocation info for local variables in function 'UART_TxChar'
                            562 ;------------------------------------------------------------
                            563 ;var_uartData_u8           Allocated to registers 
                            564 ;------------------------------------------------------------
                            565 ;	D:\Workspace\MIDE\firmware\/uart.c:139: void UART_TxChar(char var_uartData_u8)
                            566 ;	-----------------------------------------
                            567 ;	 function UART_TxChar
                            568 ;	-----------------------------------------
   008C                     569 _UART_TxChar:
   008C 85 82 99            570 	mov	_SBUF,dpl
                            571 ;	D:\Workspace\MIDE\firmware\/uart.c:142: while(TI==0);       // Wait till the data is trasmitted
   008F                     572 00101$:
                            573 ;	D:\Workspace\MIDE\firmware\/uart.c:143: TI=0;		        //Clear the Tx flag for next cycle.
   008F 10 99 02            574 	jbc	_TI,00108$
   0092 80 FB               575 	sjmp	00101$
   0094                     576 00108$:
   0094 22                  577 	ret
                            578 ;------------------------------------------------------------
                            579 ;Allocation info for local variables in function 'UART_TxString'
                            580 ;------------------------------------------------------------
                            581 ;ptr_stringPointer_u8      Allocated to registers r2 r3 r4 
                            582 ;------------------------------------------------------------
                            583 ;	D:\Workspace\MIDE\firmware\/uart.c:163: void UART_TxString(char *ptr_stringPointer_u8)
                            584 ;	-----------------------------------------
                            585 ;	 function UART_TxString
                            586 ;	-----------------------------------------
   0095                     587 _UART_TxString:
   0095 AA 82               588 	mov	r2,dpl
   0097 AB 83               589 	mov	r3,dph
   0099 AC F0               590 	mov	r4,b
                            591 ;	D:\Workspace\MIDE\firmware\/uart.c:165: while(*ptr_stringPointer_u8)
   009B                     592 00101$:
   009B 8A 82               593 	mov	dpl,r2
   009D 8B 83               594 	mov	dph,r3
   009F 8C F0               595 	mov	b,r4
   00A1 12s00r00            596 	lcall	__gptrget
   00A4 FD                  597 	mov	r5,a
   00A5 60 18               598 	jz	00104$
                            599 ;	D:\Workspace\MIDE\firmware\/uart.c:166: UART_TxChar(*ptr_stringPointer_u8++);// Loop through the string and transmit char by char
   00A7 0A                  600 	inc	r2
   00A8 BA 00 01            601 	cjne	r2,#0x00,00110$
   00AB 0B                  602 	inc	r3
   00AC                     603 00110$:
   00AC 8D 82               604 	mov	dpl,r5
   00AE C0 02               605 	push	ar2
   00B0 C0 03               606 	push	ar3
   00B2 C0 04               607 	push	ar4
   00B4 12s00r8C            608 	lcall	_UART_TxChar
   00B7 D0 04               609 	pop	ar4
   00B9 D0 03               610 	pop	ar3
   00BB D0 02               611 	pop	ar2
   00BD 80 DC               612 	sjmp	00101$
   00BF                     613 00104$:
   00BF 22                  614 	ret
                            615 ;------------------------------------------------------------
                            616 ;Allocation info for local variables in function 'UART_TxDecimalNumber'
                            617 ;------------------------------------------------------------
                            618 ;var_numOfDigitsToTransmit_u8 Allocated to stack - offset -3
                            619 ;var_decNumber_u32         Allocated to stack - offset 1
                            620 ;i                         Allocated to registers r2 
                            621 ;a                         Allocated to stack - offset 5
                            622 ;sloc0                     Allocated to stack - offset 16
                            623 ;sloc1                     Allocated to stack - offset 17
                            624 ;sloc2                     Allocated to stack - offset 15
                            625 ;------------------------------------------------------------
                            626 ;	D:\Workspace\MIDE\firmware\/uart.c:231: void UART_TxDecimalNumber(uint32_t var_decNumber_u32, uint8_t var_numOfDigitsToTransmit_u8)
                            627 ;	-----------------------------------------
                            628 ;	 function UART_TxDecimalNumber
                            629 ;	-----------------------------------------
   00C0                     630 _UART_TxDecimalNumber:
   00C0 C0*00               631 	push	_bp
   00C2 85 81*00            632 	mov	_bp,sp
   00C5 C0 82               633 	push	dpl
   00C7 C0 83               634 	push	dph
   00C9 C0 F0               635 	push	b
   00CB C0 E0               636 	push	acc
   00CD E5 81               637 	mov	a,sp
   00CF 24 12               638 	add	a,#0x12
   00D1 F5 81               639 	mov	sp,a
                            640 ;	D:\Workspace\MIDE\firmware\/uart.c:235: if(var_decNumber_u32==0)
   00D3 A8*00               641 	mov	r0,_bp
   00D5 08                  642 	inc	r0
   00D6 E6                  643 	mov	a,@r0
   00D7 08                  644 	inc	r0
   00D8 46                  645 	orl	a,@r0
   00D9 08                  646 	inc	r0
   00DA 46                  647 	orl	a,@r0
   00DB 08                  648 	inc	r0
   00DC 46                  649 	orl	a,@r0
   00DD 70 30               650 	jnz	00133$
                            651 ;	D:\Workspace\MIDE\firmware\/uart.c:238: for(i=0;((i<var_numOfDigitsToTransmit_u8) && (i<C_MaxDigitsToTransmit_U8)) ;i++)
   00DF E5*00               652 	mov	a,_bp
   00E1 24 05               653 	add	a,#0x05
   00E3 FE                  654 	mov	r6,a
   00E4 7A 00               655 	mov	r2,#0x00
   00E6                     656 00119$:
   00E6 E5*00               657 	mov	a,_bp
   00E8 24 FD               658 	add	a,#0xfd
   00EA F8                  659 	mov	r0,a
   00EB C3                  660 	clr	c
   00EC EA                  661 	mov	a,r2
   00ED 96                  662 	subb	a,@r0
   00EE 40 03               663 	jc	00139$
   00F0 02s01rEB            664 	ljmp	00136$
   00F3                     665 00139$:
   00F3 C0 06               666 	push	ar6
   00F5 8A 06               667 	mov	ar6,r2
   00F7 7F 00               668 	mov	r7,#0x00
   00F9 C3                  669 	clr	c
   00FA EE                  670 	mov	a,r6
   00FB 94 0A               671 	subb	a,#0x0A
   00FD EF                  672 	mov	a,r7
   00FE 94 00               673 	subb	a,#0x00
   0100 D0 06               674 	pop	ar6
   0102 40 03               675 	jc	00140$
   0104 02s01rEB            676 	ljmp	00136$
   0107                     677 00140$:
                            678 ;	D:\Workspace\MIDE\firmware\/uart.c:239: a[i] = 0x00;
   0107 EA                  679 	mov	a,r2
   0108 2E                  680 	add	a,r6
   0109 F8                  681 	mov	r0,a
   010A 76 00               682 	mov	@r0,#0x00
                            683 ;	D:\Workspace\MIDE\firmware\/uart.c:238: for(i=0;((i<var_numOfDigitsToTransmit_u8) && (i<C_MaxDigitsToTransmit_U8)) ;i++)
   010C 0A                  684 	inc	r2
                            685 ;	D:\Workspace\MIDE\firmware\/uart.c:243: for(i=0;i<var_numOfDigitsToTransmit_u8;i++)
   010D 80 D7               686 	sjmp	00119$
   010F                     687 00133$:
   010F E5*00               688 	mov	a,_bp
   0111 24 05               689 	add	a,#0x05
   0113 FC                  690 	mov	r4,a
   0114 7D 00               691 	mov	r5,#0x00
   0116                     692 00108$:
   0116 E5*00               693 	mov	a,_bp
   0118 24 FD               694 	add	a,#0xfd
   011A F8                  695 	mov	r0,a
   011B C3                  696 	clr	c
   011C ED                  697 	mov	a,r5
   011D 96                  698 	subb	a,@r0
   011E 40 03               699 	jc	00141$
   0120 02s01rED            700 	ljmp	00137$
   0123                     701 00141$:
                            702 ;	D:\Workspace\MIDE\firmware\/uart.c:247: if(var_decNumber_u32!=0)
   0123 A8*00               703 	mov	r0,_bp
   0125 08                  704 	inc	r0
   0126 E6                  705 	mov	a,@r0
   0127 08                  706 	inc	r0
   0128 46                  707 	orl	a,@r0
   0129 08                  708 	inc	r0
   012A 46                  709 	orl	a,@r0
   012B 08                  710 	inc	r0
   012C 46                  711 	orl	a,@r0
   012D 70 03               712 	jnz	00142$
   012F 02s01rC9            713 	ljmp	00106$
   0132                     714 00142$:
                            715 ;	D:\Workspace\MIDE\firmware\/uart.c:253: a[i]=util_GetMod32(var_decNumber_u32,10);
   0132 ED                  716 	mov	a,r5
   0133 2C                  717 	add	a,r4
   0134 F8                  718 	mov	r0,a
   0135 C0 04               719 	push	ar4
   0137 C0 05               720 	push	ar5
   0139 C0 00               721 	push	ar0
   013B 74 0A               722 	mov	a,#0x0A
   013D C0 E0               723 	push	acc
   013F E4                  724 	clr	a
   0140 C0 E0               725 	push	acc
   0142 C0 E0               726 	push	acc
   0144 C0 E0               727 	push	acc
   0146 A9*00               728 	mov	r1,_bp
   0148 09                  729 	inc	r1
   0149 87 82               730 	mov	dpl,@r1
   014B 09                  731 	inc	r1
   014C 87 83               732 	mov	dph,@r1
   014E 09                  733 	inc	r1
   014F 87 F0               734 	mov	b,@r1
   0151 09                  735 	inc	r1
   0152 E7                  736 	mov	a,@r1
   0153 12s00r00            737 	lcall	__divulong
   0156 C9                  738 	xch	a,r1
   0157 E5*00               739 	mov	a,_bp
   0159 24 0F               740 	add	a,#0x0f
   015B C9                  741 	xch	a,r1
   015C A7 82               742 	mov	@r1,dpl
   015E 09                  743 	inc	r1
   015F A7 83               744 	mov	@r1,dph
   0161 09                  745 	inc	r1
   0162 A7 F0               746 	mov	@r1,b
   0164 09                  747 	inc	r1
   0165 F7                  748 	mov	@r1,a
   0166 E5 81               749 	mov	a,sp
   0168 24 FC               750 	add	a,#0xfc
   016A F5 81               751 	mov	sp,a
   016C E5*00               752 	mov	a,_bp
   016E 24 0F               753 	add	a,#0x0f
   0170 F9                  754 	mov	r1,a
   0171 E7                  755 	mov	a,@r1
   0172 C0 E0               756 	push	acc
   0174 09                  757 	inc	r1
   0175 E7                  758 	mov	a,@r1
   0176 C0 E0               759 	push	acc
   0178 09                  760 	inc	r1
   0179 E7                  761 	mov	a,@r1
   017A C0 E0               762 	push	acc
   017C 09                  763 	inc	r1
   017D E7                  764 	mov	a,@r1
   017E C0 E0               765 	push	acc
   0180 90 00 0A            766 	mov	dptr,#(0x0A&0x00ff)
   0183 E4                  767 	clr	a
   0184 F5 F0               768 	mov	b,a
   0186 12s00r00            769 	lcall	__mullong
   0189 AF 82               770 	mov	r7,dpl
   018B AE 83               771 	mov	r6,dph
   018D AA F0               772 	mov	r2,b
   018F FB                  773 	mov	r3,a
   0190 E5 81               774 	mov	a,sp
   0192 24 FC               775 	add	a,#0xfc
   0194 F5 81               776 	mov	sp,a
   0196 D0 00               777 	pop	ar0
   0198 D0 05               778 	pop	ar5
   019A D0 04               779 	pop	ar4
   019C A9*00               780 	mov	r1,_bp
   019E 09                  781 	inc	r1
   019F E7                  782 	mov	a,@r1
   01A0 C3                  783 	clr	c
   01A1 9F                  784 	subb	a,r7
   01A2 FF                  785 	mov	r7,a
   01A3 09                  786 	inc	r1
   01A4 E7                  787 	mov	a,@r1
   01A5 9E                  788 	subb	a,r6
   01A6 FE                  789 	mov	r6,a
   01A7 09                  790 	inc	r1
   01A8 E7                  791 	mov	a,@r1
   01A9 9A                  792 	subb	a,r2
   01AA FA                  793 	mov	r2,a
   01AB 09                  794 	inc	r1
   01AC E7                  795 	mov	a,@r1
   01AD 9B                  796 	subb	a,r3
   01AE FB                  797 	mov	r3,a
   01AF A6 07               798 	mov	@r0,ar7
                            799 ;	D:\Workspace\MIDE\firmware\/uart.c:254: var_decNumber_u32=var_decNumber_u32/10;
   01B1 E5*00               800 	mov	a,_bp
   01B3 24 0F               801 	add	a,#0x0f
   01B5 F8                  802 	mov	r0,a
   01B6 A9*00               803 	mov	r1,_bp
   01B8 09                  804 	inc	r1
   01B9 E6                  805 	mov	a,@r0
   01BA F7                  806 	mov	@r1,a
   01BB 08                  807 	inc	r0
   01BC 09                  808 	inc	r1
   01BD E6                  809 	mov	a,@r0
   01BE F7                  810 	mov	@r1,a
   01BF 08                  811 	inc	r0
   01C0 09                  812 	inc	r1
   01C1 E6                  813 	mov	a,@r0
   01C2 F7                  814 	mov	@r1,a
   01C3 08                  815 	inc	r0
   01C4 09                  816 	inc	r1
   01C5 E6                  817 	mov	a,@r0
   01C6 F7                  818 	mov	@r1,a
   01C7 80 1E               819 	sjmp	00110$
   01C9                     820 00106$:
                            821 ;	D:\Workspace\MIDE\firmware\/uart.c:256: else if( (var_numOfDigitsToTransmit_u8 == C_DefaultDigitsToTransmit_U8) ||
   01C9 E5*00               822 	mov	a,_bp
   01CB 24 FD               823 	add	a,#0xfd
   01CD F8                  824 	mov	r0,a
   01CE 86 02               825 	mov	ar2,@r0
   01D0 7B 00               826 	mov	r3,#0x00
   01D2 BA FF 05            827 	cjne	r2,#0xFF,00143$
   01D5 BB 00 02            828 	cjne	r3,#0x00,00143$
   01D8 80 13               829 	sjmp	00137$
   01DA                     830 00143$:
                            831 ;	D:\Workspace\MIDE\firmware\/uart.c:257: (var_numOfDigitsToTransmit_u8 > C_MaxDigitsToTransmit_U8))
   01DA C3                  832 	clr	c
   01DB 74 0A               833 	mov	a,#0x0A
   01DD 9A                  834 	subb	a,r2
   01DE E4                  835 	clr	a
   01DF 9B                  836 	subb	a,r3
   01E0 40 0B               837 	jc	00137$
                            838 ;	D:\Workspace\MIDE\firmware\/uart.c:268: a[i]=0;
   01E2 ED                  839 	mov	a,r5
   01E3 2C                  840 	add	a,r4
   01E4 F8                  841 	mov	r0,a
   01E5 76 00               842 	mov	@r0,#0x00
   01E7                     843 00110$:
                            844 ;	D:\Workspace\MIDE\firmware\/uart.c:243: for(i=0;i<var_numOfDigitsToTransmit_u8;i++)
   01E7 0D                  845 	inc	r5
   01E8 02s01r16            846 	ljmp	00108$
                            847 ;	D:\Workspace\MIDE\firmware\/uart.c:273: while(i)
   01EB                     848 00136$:
                            849 ;	D:\Workspace\MIDE\firmware\/uart.c:277: i--;
                            850 ;	D:\Workspace\MIDE\firmware\/uart.c:273: while(i)
   01EB 80 02               851 	sjmp	00135$
   01ED                     852 00137$:
   01ED 8D 02               853 	mov	ar2,r5
   01EF                     854 00135$:
   01EF E5*00               855 	mov	a,_bp
   01F1 24 05               856 	add	a,#0x05
   01F3 FB                  857 	mov	r3,a
   01F4                     858 00115$:
   01F4 EA                  859 	mov	a,r2
   01F5 60 1B               860 	jz	00123$
                            861 ;	D:\Workspace\MIDE\firmware\/uart.c:276: UART_TxChar(util_Dec2Ascii(a[i-1]));
   01F7 EA                  862 	mov	a,r2
   01F8 14                  863 	dec	a
   01F9 FC                  864 	mov	r4,a
   01FA 2B                  865 	add	a,r3
   01FB F8                  866 	mov	r0,a
   01FC 86 05               867 	mov	ar5,@r0
   01FE 74 30               868 	mov	a,#0x30
   0200 2D                  869 	add	a,r5
   0201 F5 82               870 	mov	dpl,a
   0203 C0 03               871 	push	ar3
   0205 C0 04               872 	push	ar4
   0207 12s00r8C            873 	lcall	_UART_TxChar
   020A D0 04               874 	pop	ar4
   020C D0 03               875 	pop	ar3
                            876 ;	D:\Workspace\MIDE\firmware\/uart.c:277: i--;
   020E 8C 02               877 	mov	ar2,r4
   0210 80 E2               878 	sjmp	00115$
   0212                     879 00123$:
   0212 85*00 81            880 	mov	sp,_bp
   0215 D0*00               881 	pop	_bp
   0217 22                  882 	ret
                            883 ;------------------------------------------------------------
                            884 ;Allocation info for local variables in function 'UART_TxHexNumber'
                            885 ;------------------------------------------------------------
                            886 ;var_numOfDigitsToTransmit_u8 Allocated to stack - offset -3
                            887 ;var_hexNumber_u32         Allocated to stack - offset 1
                            888 ;i                         Allocated to registers r2 
                            889 ;a                         Allocated to stack - offset 5
                            890 ;------------------------------------------------------------
                            891 ;	D:\Workspace\MIDE\firmware\/uart.c:303: void UART_TxHexNumber(uint32_t var_hexNumber_u32,uint8_t var_numOfDigitsToTransmit_u8)
                            892 ;	-----------------------------------------
                            893 ;	 function UART_TxHexNumber
                            894 ;	-----------------------------------------
   0218                     895 _UART_TxHexNumber:
   0218 C0*00               896 	push	_bp
   021A 85 81*00            897 	mov	_bp,sp
   021D C0 82               898 	push	dpl
   021F C0 83               899 	push	dph
   0221 C0 F0               900 	push	b
   0223 C0 E0               901 	push	acc
   0225 E5 81               902 	mov	a,sp
   0227 24 0E               903 	add	a,#0x0e
   0229 F5 81               904 	mov	sp,a
                            905 ;	D:\Workspace\MIDE\firmware\/uart.c:307: if(var_hexNumber_u32==0)
   022B A8*00               906 	mov	r0,_bp
   022D 08                  907 	inc	r0
   022E E6                  908 	mov	a,@r0
   022F 08                  909 	inc	r0
   0230 46                  910 	orl	a,@r0
   0231 08                  911 	inc	r0
   0232 46                  912 	orl	a,@r0
   0233 08                  913 	inc	r0
   0234 46                  914 	orl	a,@r0
   0235 70 30               915 	jnz	00135$
                            916 ;	D:\Workspace\MIDE\firmware\/uart.c:310: for(i=0;((i<var_numOfDigitsToTransmit_u8) && (i<C_MaxDigitsToTransmit_U8)) ;i++)
   0237 E5*00               917 	mov	a,_bp
   0239 24 05               918 	add	a,#0x05
   023B FE                  919 	mov	r6,a
   023C 7A 00               920 	mov	r2,#0x00
   023E                     921 00119$:
   023E E5*00               922 	mov	a,_bp
   0240 24 FD               923 	add	a,#0xfd
   0242 F8                  924 	mov	r0,a
   0243 C3                  925 	clr	c
   0244 EA                  926 	mov	a,r2
   0245 96                  927 	subb	a,@r0
   0246 40 03               928 	jc	00143$
   0248 02s02rEF            929 	ljmp	00139$
   024B                     930 00143$:
   024B C0 06               931 	push	ar6
   024D 8A 06               932 	mov	ar6,r2
   024F 7F 00               933 	mov	r7,#0x00
   0251 C3                  934 	clr	c
   0252 EE                  935 	mov	a,r6
   0253 94 0A               936 	subb	a,#0x0A
   0255 EF                  937 	mov	a,r7
   0256 94 00               938 	subb	a,#0x00
   0258 D0 06               939 	pop	ar6
   025A 40 03               940 	jc	00144$
   025C 02s02rEF            941 	ljmp	00139$
   025F                     942 00144$:
                            943 ;	D:\Workspace\MIDE\firmware\/uart.c:311: a[i]=0x00;
   025F EA                  944 	mov	a,r2
   0260 2E                  945 	add	a,r6
   0261 F8                  946 	mov	r0,a
   0262 76 00               947 	mov	@r0,#0x00
                            948 ;	D:\Workspace\MIDE\firmware\/uart.c:310: for(i=0;((i<var_numOfDigitsToTransmit_u8) && (i<C_MaxDigitsToTransmit_U8)) ;i++)
   0264 0A                  949 	inc	r2
                            950 ;	D:\Workspace\MIDE\firmware\/uart.c:315: for(i=0;i<var_numOfDigitsToTransmit_u8;i++)
   0265 80 D7               951 	sjmp	00119$
   0267                     952 00135$:
   0267 E5*00               953 	mov	a,_bp
   0269 24 05               954 	add	a,#0x05
   026B FE                  955 	mov	r6,a
   026C 7F 00               956 	mov	r7,#0x00
   026E                     957 00108$:
   026E E5*00               958 	mov	a,_bp
   0270 24 FD               959 	add	a,#0xfd
   0272 F8                  960 	mov	r0,a
   0273 C3                  961 	clr	c
   0274 EF                  962 	mov	a,r7
   0275 96                  963 	subb	a,@r0
   0276 40 03               964 	jc	00145$
   0278 02s02rF1            965 	ljmp	00140$
   027B                     966 00145$:
                            967 ;	D:\Workspace\MIDE\firmware\/uart.c:318: if(var_hexNumber_u32!=0)
   027B A8*00               968 	mov	r0,_bp
   027D 08                  969 	inc	r0
   027E E6                  970 	mov	a,@r0
   027F 08                  971 	inc	r0
   0280 46                  972 	orl	a,@r0
   0281 08                  973 	inc	r0
   0282 46                  974 	orl	a,@r0
   0283 08                  975 	inc	r0
   0284 46                  976 	orl	a,@r0
   0285 60 46               977 	jz	00106$
                            978 ;	D:\Workspace\MIDE\firmware\/uart.c:324: a[i]=(uint8_t)(var_hexNumber_u32 & 0x0f);
   0287 EF                  979 	mov	a,r7
   0288 2E                  980 	add	a,r6
   0289 F8                  981 	mov	r0,a
   028A C0 06               982 	push	ar6
   028C A9*00               983 	mov	r1,_bp
   028E 09                  984 	inc	r1
   028F 74 0F               985 	mov	a,#0x0F
   0291 57                  986 	anl	a,@r1
   0292 FE                  987 	mov	r6,a
   0293 7A 00               988 	mov	r2,#0x00
   0295 7B 00               989 	mov	r3,#0x00
   0297 7C 00               990 	mov	r4,#0x00
   0299 A6 06               991 	mov	@r0,ar6
                            992 ;	D:\Workspace\MIDE\firmware\/uart.c:325: var_hexNumber_u32=var_hexNumber_u32 >> 4;
   029B A8*00               993 	mov	r0,_bp
   029D 08                  994 	inc	r0
   029E 08                  995 	inc	r0
   029F E6                  996 	mov	a,@r0
   02A0 18                  997 	dec	r0
   02A1 C4                  998 	swap	a
   02A2 C6                  999 	xch	a,@r0
   02A3 C4                 1000 	swap	a
   02A4 54 0F              1001 	anl	a,#0x0f
   02A6 66                 1002 	xrl	a,@r0
   02A7 C6                 1003 	xch	a,@r0
   02A8 54 0F              1004 	anl	a,#0x0f
   02AA C6                 1005 	xch	a,@r0
   02AB 66                 1006 	xrl	a,@r0
   02AC C6                 1007 	xch	a,@r0
   02AD 08                 1008 	inc	r0
   02AE F6                 1009 	mov	@r0,a
   02AF 08                 1010 	inc	r0
   02B0 E6                 1011 	mov	a,@r0
   02B1 C4                 1012 	swap	a
   02B2 54 F0              1013 	anl	a,#0xf0
   02B4 18                 1014 	dec	r0
   02B5 46                 1015 	orl	a,@r0
   02B6 F6                 1016 	mov	@r0,a
   02B7 08                 1017 	inc	r0
   02B8 08                 1018 	inc	r0
   02B9 E6                 1019 	mov	a,@r0
   02BA 18                 1020 	dec	r0
   02BB C4                 1021 	swap	a
   02BC C6                 1022 	xch	a,@r0
   02BD C4                 1023 	swap	a
   02BE 54 0F              1024 	anl	a,#0x0f
   02C0 66                 1025 	xrl	a,@r0
   02C1 C6                 1026 	xch	a,@r0
   02C2 54 0F              1027 	anl	a,#0x0f
   02C4 C6                 1028 	xch	a,@r0
   02C5 66                 1029 	xrl	a,@r0
   02C6 C6                 1030 	xch	a,@r0
   02C7 08                 1031 	inc	r0
   02C8 F6                 1032 	mov	@r0,a
   02C9 D0 06              1033 	pop	ar6
   02CB 80 1E              1034 	sjmp	00110$
   02CD                    1035 00106$:
                           1036 ;	D:\Workspace\MIDE\firmware\/uart.c:327: else if( (var_numOfDigitsToTransmit_u8 == C_DefaultDigitsToTransmit_U8) ||
   02CD E5*00              1037 	mov	a,_bp
   02CF 24 FD              1038 	add	a,#0xfd
   02D1 F8                 1039 	mov	r0,a
   02D2 86 02              1040 	mov	ar2,@r0
   02D4 7B 00              1041 	mov	r3,#0x00
   02D6 BA FF 05           1042 	cjne	r2,#0xFF,00147$
   02D9 BB 00 02           1043 	cjne	r3,#0x00,00147$
   02DC 80 13              1044 	sjmp	00140$
   02DE                    1045 00147$:
                           1046 ;	D:\Workspace\MIDE\firmware\/uart.c:328: (var_numOfDigitsToTransmit_u8 > C_MaxDigitsToTransmit_U8))
   02DE C3                 1047 	clr	c
   02DF 74 0A              1048 	mov	a,#0x0A
   02E1 9A                 1049 	subb	a,r2
   02E2 E4                 1050 	clr	a
   02E3 9B                 1051 	subb	a,r3
   02E4 40 0B              1052 	jc	00140$
                           1053 ;	D:\Workspace\MIDE\firmware\/uart.c:339: a[i]=0x00;
   02E6 EF                 1054 	mov	a,r7
   02E7 2E                 1055 	add	a,r6
   02E8 F8                 1056 	mov	r0,a
   02E9 76 00              1057 	mov	@r0,#0x00
   02EB                    1058 00110$:
                           1059 ;	D:\Workspace\MIDE\firmware\/uart.c:315: for(i=0;i<var_numOfDigitsToTransmit_u8;i++)
   02EB 0F                 1060 	inc	r7
   02EC 02s02r6E           1061 	ljmp	00108$
                           1062 ;	D:\Workspace\MIDE\firmware\/uart.c:344: while(i!=0)
   02EF                    1063 00139$:
                           1064 ;	D:\Workspace\MIDE\firmware\/uart.c:348: i--;
                           1065 ;	D:\Workspace\MIDE\firmware\/uart.c:344: while(i!=0)
   02EF 80 02              1066 	sjmp	00138$
   02F1                    1067 00140$:
   02F1 8F 02              1068 	mov	ar2,r7
   02F3                    1069 00138$:
   02F3 E5*00              1070 	mov	a,_bp
   02F5 24 05              1071 	add	a,#0x05
   02F7 FB                 1072 	mov	r3,a
   02F8                    1073 00115$:
   02F8 EA                 1074 	mov	a,r2
   02F9 60 33              1075 	jz	00123$
                           1076 ;	D:\Workspace\MIDE\firmware\/uart.c:347: UART_TxChar(util_Hex2Ascii(a[i-1]));
   02FB EA                 1077 	mov	a,r2
   02FC 14                 1078 	dec	a
   02FD 2B                 1079 	add	a,r3
   02FE F8                 1080 	mov	r0,a
   02FF 86 04              1081 	mov	ar4,@r0
   0301 74 09              1082 	mov	a,#0x09
   0303 B5 04 00           1083 	cjne	a,ar4,00150$
   0306                    1084 00150$:
   0306 50 0C              1085 	jnc	00125$
   0308 EA                 1086 	mov	a,r2
   0309 14                 1087 	dec	a
   030A 2B                 1088 	add	a,r3
   030B F8                 1089 	mov	r0,a
   030C 86 04              1090 	mov	ar4,@r0
   030E 74 37              1091 	mov	a,#0x37
   0310 2C                 1092 	add	a,r4
   0311 FC                 1093 	mov	r4,a
   0312 80 0A              1094 	sjmp	00126$
   0314                    1095 00125$:
   0314 EA                 1096 	mov	a,r2
   0315 14                 1097 	dec	a
   0316 2B                 1098 	add	a,r3
   0317 F8                 1099 	mov	r0,a
   0318 86 05              1100 	mov	ar5,@r0
   031A 74 30              1101 	mov	a,#0x30
   031C 2D                 1102 	add	a,r5
   031D FC                 1103 	mov	r4,a
   031E                    1104 00126$:
   031E 8C 82              1105 	mov	dpl,r4
   0320 C0 02              1106 	push	ar2
   0322 C0 03              1107 	push	ar3
   0324 12s00r8C           1108 	lcall	_UART_TxChar
   0327 D0 03              1109 	pop	ar3
   0329 D0 02              1110 	pop	ar2
                           1111 ;	D:\Workspace\MIDE\firmware\/uart.c:348: i--;
   032B 1A                 1112 	dec	r2
   032C 80 CA              1113 	sjmp	00115$
   032E                    1114 00123$:
   032E 85*00 81           1115 	mov	sp,_bp
   0331 D0*00              1116 	pop	_bp
   0333 22                 1117 	ret
                           1118 ;------------------------------------------------------------
                           1119 ;Allocation info for local variables in function 'UART_Printf'
                           1120 ;------------------------------------------------------------
                           1121 ;argList                   Allocated to stack - offset -5
                           1122 ;ptr                       Allocated to registers r3 r4 r5 
                           1123 ;var_floatNum_f32          Allocated to registers 
                           1124 ;argp                      Allocated to stack - offset 1
                           1125 ;var_num_s16               Allocated to registers r2 r6 
                           1126 ;var_num_s32               Allocated to stack - offset 2
                           1127 ;var_num_u16               Allocated to registers r2 r6 
                           1128 ;var_num_u32               Allocated to stack - offset 6
                           1129 ;str                       Allocated to registers r2 r6 r7 
                           1130 ;ch                        Allocated to stack - offset 10
                           1131 ;var_numOfDigitsToTransmit_u8 Allocated to stack - offset 11
                           1132 ;sloc0                     Allocated to stack - offset 12
                           1133 ;------------------------------------------------------------
                           1134 ;	D:\Workspace\MIDE\firmware\/uart.c:468: void UART_Printf(const char *argList, ...)
                           1135 ;	-----------------------------------------
                           1136 ;	 function UART_Printf
                           1137 ;	-----------------------------------------
   0334                    1138 _UART_Printf:
   0334 C0*00              1139 	push	_bp
   0336 E5 81              1140 	mov	a,sp
   0338 F5*00              1141 	mov	_bp,a
   033A 24 0E              1142 	add	a,#0x0e
   033C F5 81              1143 	mov	sp,a
                           1144 ;	D:\Workspace\MIDE\firmware\/uart.c:481: va_start(argp, argList);
   033E E5*00              1145 	mov	a,_bp
   0340 24 FB              1146 	add	a,#0xfb
   0342 FA                 1147 	mov	r2,a
   0343 A8*00              1148 	mov	r0,_bp
   0345 08                 1149 	inc	r0
   0346 A6 02              1150 	mov	@r0,ar2
                           1151 ;	D:\Workspace\MIDE\firmware\/uart.c:484: for(ptr = argList; *ptr != '\0'; ptr++)
   0348 E5*00              1152 	mov	a,_bp
   034A 24 FB              1153 	add	a,#0xfb
   034C F8                 1154 	mov	r0,a
   034D 86 03              1155 	mov	ar3,@r0
   034F 08                 1156 	inc	r0
   0350 86 04              1157 	mov	ar4,@r0
   0352 08                 1158 	inc	r0
   0353 86 05              1159 	mov	ar5,@r0
   0355                    1160 00132$:
   0355 8B 82              1161 	mov	dpl,r3
   0357 8C 83              1162 	mov	dph,r4
   0359 8D F0              1163 	mov	b,r5
   035B 12s00r00           1164 	lcall	__gptrget
   035E FE                 1165 	mov	r6,a
   035F BE 00 03           1166 	cjne	r6,#0x00,00164$
   0362 02s07rBB           1167 	ljmp	00136$
   0365                    1168 00164$:
                           1169 ;	D:\Workspace\MIDE\firmware\/uart.c:487: ch= *ptr;
   0365 E5*00              1170 	mov	a,_bp
   0367 24 0A              1171 	add	a,#0x0a
   0369 F8                 1172 	mov	r0,a
   036A A6 06              1173 	mov	@r0,ar6
                           1174 ;	D:\Workspace\MIDE\firmware\/uart.c:488: if(ch == '%')         /*Check for '%' as there will be format specifier after it */
   036C E5*00              1175 	mov	a,_bp
   036E 24 0A              1176 	add	a,#0x0a
   0370 F8                 1177 	mov	r0,a
   0371 B6 25 02           1178 	cjne	@r0,#0x25,00165$
   0374 80 03              1179 	sjmp	00166$
   0376                    1180 00165$:
   0376 02s07r9D           1181 	ljmp	00130$
   0379                    1182 00166$:
                           1183 ;	D:\Workspace\MIDE\firmware\/uart.c:490: ptr++;
   0379 0B                 1184 	inc	r3
   037A BB 00 01           1185 	cjne	r3,#0x00,00167$
   037D 0C                 1186 	inc	r4
   037E                    1187 00167$:
                           1188 ;	D:\Workspace\MIDE\firmware\/uart.c:491: ch = *ptr;
   037E 8B 82              1189 	mov	dpl,r3
   0380 8C 83              1190 	mov	dph,r4
   0382 8D F0              1191 	mov	b,r5
   0384 12s00r00           1192 	lcall	__gptrget
   0387 FF                 1193 	mov	r7,a
   0388 E5*00              1194 	mov	a,_bp
   038A 24 0A              1195 	add	a,#0x0a
   038C F8                 1196 	mov	r0,a
   038D A6 07              1197 	mov	@r0,ar7
                           1198 ;	D:\Workspace\MIDE\firmware\/uart.c:492: if((ch>=0x30) && (ch<=0x39))
   038F E5*00              1199 	mov	a,_bp
   0391 24 0A              1200 	add	a,#0x0a
   0393 F8                 1201 	mov	r0,a
   0394 C3                 1202 	clr	c
   0395 E6                 1203 	mov	a,@r0
   0396 64 80              1204 	xrl	a,#0x80
   0398 94 B0              1205 	subb	a,#0xb0
   039A 50 03              1206 	jnc	00168$
   039C 02s04r26           1207 	ljmp	00106$
   039F                    1208 00168$:
   039F E5*00              1209 	mov	a,_bp
   03A1 24 0A              1210 	add	a,#0x0a
   03A3 F8                 1211 	mov	r0,a
   03A4 C3                 1212 	clr	c
   03A5 74 B9              1213 	mov	a,#(0x39 ^ 0x80)
   03A7 86 F0              1214 	mov	b,@r0
   03A9 63 F0 80           1215 	xrl	b,#0x80
   03AC 95 F0              1216 	subb	a,b
   03AE 50 03              1217 	jnc	00169$
   03B0 02s04r26           1218 	ljmp	00106$
   03B3                    1219 00169$:
                           1220 ;	D:\Workspace\MIDE\firmware\/uart.c:494: var_numOfDigitsToTransmit_u8 = 0;
   03B3 E5*00              1221 	mov	a,_bp
   03B5 24 0B              1222 	add	a,#0x0b
   03B7 F8                 1223 	mov	r0,a
   03B8 76 00              1224 	mov	@r0,#0x00
                           1225 ;	D:\Workspace\MIDE\firmware\/uart.c:495: while((ch>=0x30) && (ch<=0x39))
   03BA E5*00              1226 	mov	a,_bp
   03BC 24 0C              1227 	add	a,#0x0c
   03BE F8                 1228 	mov	r0,a
   03BF A6 03              1229 	mov	@r0,ar3
   03C1 08                 1230 	inc	r0
   03C2 A6 04              1231 	mov	@r0,ar4
   03C4 08                 1232 	inc	r0
   03C5 A6 05              1233 	mov	@r0,ar5
   03C7                    1234 00102$:
   03C7 E5*00              1235 	mov	a,_bp
   03C9 24 0A              1236 	add	a,#0x0a
   03CB F8                 1237 	mov	r0,a
   03CC C3                 1238 	clr	c
   03CD E6                 1239 	mov	a,@r0
   03CE 64 80              1240 	xrl	a,#0x80
   03D0 94 B0              1241 	subb	a,#0xb0
   03D2 40 5B              1242 	jc	00163$
   03D4 E5*00              1243 	mov	a,_bp
   03D6 24 0A              1244 	add	a,#0x0a
   03D8 F8                 1245 	mov	r0,a
   03D9 C3                 1246 	clr	c
   03DA 74 B9              1247 	mov	a,#(0x39 ^ 0x80)
   03DC 86 F0              1248 	mov	b,@r0
   03DE 63 F0 80           1249 	xrl	b,#0x80
   03E1 95 F0              1250 	subb	a,b
   03E3 40 4A              1251 	jc	00163$
                           1252 ;	D:\Workspace\MIDE\firmware\/uart.c:497: var_numOfDigitsToTransmit_u8 = (var_numOfDigitsToTransmit_u8 * 10) + (ch-0x30);
   03E5 E5*00              1253 	mov	a,_bp
   03E7 24 0B              1254 	add	a,#0x0b
   03E9 F8                 1255 	mov	r0,a
   03EA E6                 1256 	mov	a,@r0
   03EB 75 F0 0A           1257 	mov	b,#0x0A
   03EE A4                 1258 	mul	ab
   03EF FA                 1259 	mov	r2,a
   03F0 E5*00              1260 	mov	a,_bp
   03F2 24 0A              1261 	add	a,#0x0a
   03F4 F8                 1262 	mov	r0,a
   03F5 E6                 1263 	mov	a,@r0
   03F6 24 D0              1264 	add	a,#0xd0
   03F8 2A                 1265 	add	a,r2
   03F9 FA                 1266 	mov	r2,a
   03FA E5*00              1267 	mov	a,_bp
   03FC 24 0B              1268 	add	a,#0x0b
   03FE F8                 1269 	mov	r0,a
   03FF A6 02              1270 	mov	@r0,ar2
                           1271 ;	D:\Workspace\MIDE\firmware\/uart.c:498: ptr++;
   0401 E5*00              1272 	mov	a,_bp
   0403 24 0C              1273 	add	a,#0x0c
   0405 F8                 1274 	mov	r0,a
   0406 06                 1275 	inc	@r0
   0407 B6 00 02           1276 	cjne	@r0,#0x00,00172$
   040A 08                 1277 	inc	r0
   040B 06                 1278 	inc	@r0
   040C                    1279 00172$:
                           1280 ;	D:\Workspace\MIDE\firmware\/uart.c:499: ch = *ptr;
   040C E5*00              1281 	mov	a,_bp
   040E 24 0C              1282 	add	a,#0x0c
   0410 F8                 1283 	mov	r0,a
   0411 86 82              1284 	mov	dpl,@r0
   0413 08                 1285 	inc	r0
   0414 86 83              1286 	mov	dph,@r0
   0416 08                 1287 	inc	r0
   0417 86 F0              1288 	mov	b,@r0
   0419 12s00r00           1289 	lcall	__gptrget
   041C FA                 1290 	mov	r2,a
   041D E5*00              1291 	mov	a,_bp
   041F 24 0A              1292 	add	a,#0x0a
   0421 F8                 1293 	mov	r0,a
   0422 A6 02              1294 	mov	@r0,ar2
   0424 80 A1              1295 	sjmp	00102$
   0426                    1296 00106$:
                           1297 ;	D:\Workspace\MIDE\firmware\/uart.c:504: var_numOfDigitsToTransmit_u8 = C_MaxDigitsToTransmitUsingPrintf_U8;
   0426 E5*00              1298 	mov	a,_bp
   0428 24 0B              1299 	add	a,#0x0b
   042A F8                 1300 	mov	r0,a
   042B 76 FF              1301 	mov	@r0,#0xFF
                           1302 ;	D:\Workspace\MIDE\firmware\/uart.c:617: va_end(argp);
                           1303 ;	D:\Workspace\MIDE\firmware\/uart.c:504: var_numOfDigitsToTransmit_u8 = C_MaxDigitsToTransmitUsingPrintf_U8;
   042D 80 0D              1304 	sjmp	00107$
   042F                    1305 00163$:
   042F E5*00              1306 	mov	a,_bp
   0431 24 0C              1307 	add	a,#0x0c
   0433 F8                 1308 	mov	r0,a
   0434 86 03              1309 	mov	ar3,@r0
   0436 08                 1310 	inc	r0
   0437 86 04              1311 	mov	ar4,@r0
   0439 08                 1312 	inc	r0
   043A 86 05              1313 	mov	ar5,@r0
   043C                    1314 00107$:
                           1315 ;	D:\Workspace\MIDE\firmware\/uart.c:508: switch(ch)       /* Decode the type of the argument */
   043C E5*00              1316 	mov	a,_bp
   043E 24 0A              1317 	add	a,#0x0a
   0440 F8                 1318 	mov	r0,a
   0441 B6 25 03           1319 	cjne	@r0,#0x25,00173$
   0444 02s07r89           1320 	ljmp	00127$
   0447                    1321 00173$:
   0447 E5*00              1322 	mov	a,_bp
   0449 24 0A              1323 	add	a,#0x0a
   044B F8                 1324 	mov	r0,a
   044C B6 42 03           1325 	cjne	@r0,#0x42,00174$
   044F 02s07r4A           1326 	ljmp	00122$
   0452                    1327 00174$:
   0452 E5*00              1328 	mov	a,_bp
   0454 24 0A              1329 	add	a,#0x0a
   0456 F8                 1330 	mov	r0,a
   0457 B6 43 03           1331 	cjne	@r0,#0x43,00175$
   045A 02s04rE2           1332 	ljmp	00110$
   045D                    1333 00175$:
   045D E5*00              1334 	mov	a,_bp
   045F 24 0A              1335 	add	a,#0x0a
   0461 F8                 1336 	mov	r0,a
   0462 B6 44 03           1337 	cjne	@r0,#0x44,00176$
   0465 02s05r80           1338 	ljmp	00114$
   0468                    1339 00176$:
   0468 E5*00              1340 	mov	a,_bp
   046A 24 0A              1341 	add	a,#0x0a
   046C F8                 1342 	mov	r0,a
   046D B6 46 03           1343 	cjne	@r0,#0x46,00177$
   0470 02s07r53           1344 	ljmp	00124$
   0473                    1345 00177$:
   0473 E5*00              1346 	mov	a,_bp
   0475 24 0A              1347 	add	a,#0x0a
   0477 F8                 1348 	mov	r0,a
   0478 B6 53 03           1349 	cjne	@r0,#0x53,00178$
   047B 02s07r5C           1350 	ljmp	00126$
   047E                    1351 00178$:
   047E E5*00              1352 	mov	a,_bp
   0480 24 0A              1353 	add	a,#0x0a
   0482 F8                 1354 	mov	r0,a
   0483 B6 55 03           1355 	cjne	@r0,#0x55,00179$
   0486 02s06r49           1356 	ljmp	00118$
   0489                    1357 00179$:
   0489 E5*00              1358 	mov	a,_bp
   048B 24 0A              1359 	add	a,#0x0a
   048D F8                 1360 	mov	r0,a
   048E B6 58 03           1361 	cjne	@r0,#0x58,00180$
   0491 02s06rE3           1362 	ljmp	00120$
   0494                    1363 00180$:
   0494 E5*00              1364 	mov	a,_bp
   0496 24 0A              1365 	add	a,#0x0a
   0498 F8                 1366 	mov	r0,a
   0499 B6 62 03           1367 	cjne	@r0,#0x62,00181$
   049C 02s07r43           1368 	ljmp	00121$
   049F                    1369 00181$:
   049F E5*00              1370 	mov	a,_bp
   04A1 24 0A              1371 	add	a,#0x0a
   04A3 F8                 1372 	mov	r0,a
   04A4 B6 63 02           1373 	cjne	@r0,#0x63,00182$
   04A7 80 39              1374 	sjmp	00110$
   04A9                    1375 00182$:
   04A9 E5*00              1376 	mov	a,_bp
   04AB 24 0A              1377 	add	a,#0x0a
   04AD F8                 1378 	mov	r0,a
   04AE B6 64 02           1379 	cjne	@r0,#0x64,00183$
   04B1 80 61              1380 	sjmp	00111$
   04B3                    1381 00183$:
   04B3 E5*00              1382 	mov	a,_bp
   04B5 24 0A              1383 	add	a,#0x0a
   04B7 F8                 1384 	mov	r0,a
   04B8 B6 66 03           1385 	cjne	@r0,#0x66,00184$
   04BB 02s07r53           1386 	ljmp	00124$
   04BE                    1387 00184$:
   04BE E5*00              1388 	mov	a,_bp
   04C0 24 0A              1389 	add	a,#0x0a
   04C2 F8                 1390 	mov	r0,a
   04C3 B6 73 03           1391 	cjne	@r0,#0x73,00185$
   04C6 02s07r5C           1392 	ljmp	00126$
   04C9                    1393 00185$:
   04C9 E5*00              1394 	mov	a,_bp
   04CB 24 0A              1395 	add	a,#0x0a
   04CD F8                 1396 	mov	r0,a
   04CE B6 75 03           1397 	cjne	@r0,#0x75,00186$
   04D1 02s06r00           1398 	ljmp	00117$
   04D4                    1399 00186$:
   04D4 E5*00              1400 	mov	a,_bp
   04D6 24 0A              1401 	add	a,#0x0a
   04D8 F8                 1402 	mov	r0,a
   04D9 B6 78 03           1403 	cjne	@r0,#0x78,00187$
   04DC 02s06r9A           1404 	ljmp	00119$
   04DF                    1405 00187$:
   04DF 02s07rB3           1406 	ljmp	00134$
                           1407 ;	D:\Workspace\MIDE\firmware\/uart.c:511: case 'c':     /* Argument type is of char, hence read char data from the argp */
   04E2                    1408 00110$:
                           1409 ;	D:\Workspace\MIDE\firmware\/uart.c:512: ch = va_arg(argp, uint16_t);
   04E2 A9*00              1410 	mov	r1,_bp
   04E4 09                 1411 	inc	r1
   04E5 E7                 1412 	mov	a,@r1
   04E6 24 FE              1413 	add	a,#0xfe
   04E8 F8                 1414 	mov	r0,a
   04E9 A9*00              1415 	mov	r1,_bp
   04EB 09                 1416 	inc	r1
   04EC A7 00              1417 	mov	@r1,ar0
   04EE 86 02              1418 	mov	ar2,@r0
   04F0 08                 1419 	inc	r0
   04F1 86 06              1420 	mov	ar6,@r0
   04F3 18                 1421 	dec	r0
   04F4 E5*00              1422 	mov	a,_bp
   04F6 24 0A              1423 	add	a,#0x0a
   04F8 F8                 1424 	mov	r0,a
   04F9 A6 02              1425 	mov	@r0,ar2
                           1426 ;	D:\Workspace\MIDE\firmware\/uart.c:513: UART_TxChar(ch);
   04FB E5*00              1427 	mov	a,_bp
   04FD 24 0A              1428 	add	a,#0x0a
   04FF F8                 1429 	mov	r0,a
   0500 86 82              1430 	mov	dpl,@r0
   0502 C0 03              1431 	push	ar3
   0504 C0 04              1432 	push	ar4
   0506 C0 05              1433 	push	ar5
   0508 12s00r8C           1434 	lcall	_UART_TxChar
   050B D0 05              1435 	pop	ar5
   050D D0 04              1436 	pop	ar4
   050F D0 03              1437 	pop	ar3
                           1438 ;	D:\Workspace\MIDE\firmware\/uart.c:514: break;
   0511 02s07rB3           1439 	ljmp	00134$
                           1440 ;	D:\Workspace\MIDE\firmware\/uart.c:516: case 'd':    /* Argument type is of signed integer, hence read 16bit data from the argp */
   0514                    1441 00111$:
                           1442 ;	D:\Workspace\MIDE\firmware\/uart.c:517: var_num_s16 = va_arg(argp, sint16_t);
   0514 A9*00              1443 	mov	r1,_bp
   0516 09                 1444 	inc	r1
   0517 E7                 1445 	mov	a,@r1
   0518 24 FE              1446 	add	a,#0xfe
   051A F8                 1447 	mov	r0,a
   051B A9*00              1448 	mov	r1,_bp
   051D 09                 1449 	inc	r1
   051E A7 00              1450 	mov	@r1,ar0
   0520 86 02              1451 	mov	ar2,@r0
   0522 08                 1452 	inc	r0
   0523 86 06              1453 	mov	ar6,@r0
   0525 18                 1454 	dec	r0
                           1455 ;	D:\Workspace\MIDE\firmware\/uart.c:519: if(var_num_s16<0)
   0526 EE                 1456 	mov	a,r6
   0527 30 E7 21           1457 	jnb	acc.7,00113$
                           1458 ;	D:\Workspace\MIDE\firmware\/uart.c:521: var_num_s16 = -var_num_s16;
   052A C3                 1459 	clr	c
   052B E4                 1460 	clr	a
   052C 9A                 1461 	subb	a,r2
   052D FA                 1462 	mov	r2,a
   052E E4                 1463 	clr	a
   052F 9E                 1464 	subb	a,r6
   0530 FE                 1465 	mov	r6,a
                           1466 ;	D:\Workspace\MIDE\firmware\/uart.c:522: UART_TxChar('-');
   0531 75 82 2D           1467 	mov	dpl,#0x2D
   0534 C0 02              1468 	push	ar2
   0536 C0 03              1469 	push	ar3
   0538 C0 04              1470 	push	ar4
   053A C0 05              1471 	push	ar5
   053C C0 06              1472 	push	ar6
   053E 12s00r8C           1473 	lcall	_UART_TxChar
   0541 D0 06              1474 	pop	ar6
   0543 D0 05              1475 	pop	ar5
   0545 D0 04              1476 	pop	ar4
   0547 D0 03              1477 	pop	ar3
   0549 D0 02              1478 	pop	ar2
   054B                    1479 00113$:
                           1480 ;	D:\Workspace\MIDE\firmware\/uart.c:524: UART_TxDecimalNumber(var_num_s16,var_numOfDigitsToTransmit_u8);
   054B C0 03              1481 	push	ar3
   054D C0 04              1482 	push	ar4
   054F C0 05              1483 	push	ar5
   0551 EE                 1484 	mov	a,r6
   0552 33                 1485 	rlc	a
   0553 95 E0              1486 	subb	a,acc
   0555 FF                 1487 	mov	r7,a
   0556 FB                 1488 	mov	r3,a
   0557 C0 03              1489 	push	ar3
   0559 C0 04              1490 	push	ar4
   055B C0 05              1491 	push	ar5
   055D E5*00              1492 	mov	a,_bp
   055F 24 0B              1493 	add	a,#0x0b
   0561 F8                 1494 	mov	r0,a
   0562 E6                 1495 	mov	a,@r0
   0563 C0 E0              1496 	push	acc
   0565 8A 82              1497 	mov	dpl,r2
   0567 8E 83              1498 	mov	dph,r6
   0569 8F F0              1499 	mov	b,r7
   056B EB                 1500 	mov	a,r3
   056C 12s00rC0           1501 	lcall	_UART_TxDecimalNumber
   056F 15 81              1502 	dec	sp
   0571 D0 05              1503 	pop	ar5
   0573 D0 04              1504 	pop	ar4
   0575 D0 03              1505 	pop	ar3
                           1506 ;	D:\Workspace\MIDE\firmware\/uart.c:526: break;
   0577 D0 05              1507 	pop	ar5
   0579 D0 04              1508 	pop	ar4
   057B D0 03              1509 	pop	ar3
   057D 02s07rB3           1510 	ljmp	00134$
                           1511 ;	D:\Workspace\MIDE\firmware\/uart.c:528: case 'D':    /* Argument type is of integer, hence read 16bit data from the argp */
   0580                    1512 00114$:
                           1513 ;	D:\Workspace\MIDE\firmware\/uart.c:529: var_num_s32 = va_arg(argp, sint32_t);
   0580 A9*00              1514 	mov	r1,_bp
   0582 09                 1515 	inc	r1
   0583 E7                 1516 	mov	a,@r1
   0584 24 FC              1517 	add	a,#0xfc
   0586 F8                 1518 	mov	r0,a
   0587 A9*00              1519 	mov	r1,_bp
   0589 09                 1520 	inc	r1
   058A A7 00              1521 	mov	@r1,ar0
   058C A9*00              1522 	mov	r1,_bp
   058E 09                 1523 	inc	r1
   058F 09                 1524 	inc	r1
   0590 E6                 1525 	mov	a,@r0
   0591 F7                 1526 	mov	@r1,a
   0592 08                 1527 	inc	r0
   0593 E6                 1528 	mov	a,@r0
   0594 09                 1529 	inc	r1
   0595 F7                 1530 	mov	@r1,a
   0596 08                 1531 	inc	r0
   0597 E6                 1532 	mov	a,@r0
   0598 09                 1533 	inc	r1
   0599 F7                 1534 	mov	@r1,a
   059A 08                 1535 	inc	r0
   059B E6                 1536 	mov	a,@r0
   059C 09                 1537 	inc	r1
   059D F7                 1538 	mov	@r1,a
   059E 18                 1539 	dec	r0
   059F 18                 1540 	dec	r0
   05A0 18                 1541 	dec	r0
   05A1 A8*00              1542 	mov	r0,_bp
   05A3 08                 1543 	inc	r0
   05A4 08                 1544 	inc	r0
                           1545 ;	D:\Workspace\MIDE\firmware\/uart.c:531: if(var_num_s32<0)
   05A5 A8*00              1546 	mov	r0,_bp
   05A7 08                 1547 	inc	r0
   05A8 08                 1548 	inc	r0
   05A9 08                 1549 	inc	r0
   05AA 08                 1550 	inc	r0
   05AB 08                 1551 	inc	r0
   05AC E6                 1552 	mov	a,@r0
   05AD 30 E7 26           1553 	jnb	acc.7,00116$
                           1554 ;	D:\Workspace\MIDE\firmware\/uart.c:533: var_num_s32 = -var_num_s32;
   05B0 A8*00              1555 	mov	r0,_bp
   05B2 08                 1556 	inc	r0
   05B3 08                 1557 	inc	r0
   05B4 C3                 1558 	clr	c
   05B5 E4                 1559 	clr	a
   05B6 96                 1560 	subb	a,@r0
   05B7 F6                 1561 	mov	@r0,a
   05B8 08                 1562 	inc	r0
   05B9 E4                 1563 	clr	a
   05BA 96                 1564 	subb	a,@r0
   05BB F6                 1565 	mov	@r0,a
   05BC 08                 1566 	inc	r0
   05BD E4                 1567 	clr	a
   05BE 96                 1568 	subb	a,@r0
   05BF F6                 1569 	mov	@r0,a
   05C0 08                 1570 	inc	r0
   05C1 E4                 1571 	clr	a
   05C2 96                 1572 	subb	a,@r0
   05C3 F6                 1573 	mov	@r0,a
                           1574 ;	D:\Workspace\MIDE\firmware\/uart.c:534: UART_TxChar('-');
   05C4 75 82 2D           1575 	mov	dpl,#0x2D
   05C7 C0 03              1576 	push	ar3
   05C9 C0 04              1577 	push	ar4
   05CB C0 05              1578 	push	ar5
   05CD 12s00r8C           1579 	lcall	_UART_TxChar
   05D0 D0 05              1580 	pop	ar5
   05D2 D0 04              1581 	pop	ar4
   05D4 D0 03              1582 	pop	ar3
   05D6                    1583 00116$:
                           1584 ;	D:\Workspace\MIDE\firmware\/uart.c:536: UART_TxDecimalNumber(var_num_s32,var_numOfDigitsToTransmit_u8);
   05D6 C0 03              1585 	push	ar3
   05D8 C0 04              1586 	push	ar4
   05DA C0 05              1587 	push	ar5
   05DC E5*00              1588 	mov	a,_bp
   05DE 24 0B              1589 	add	a,#0x0b
   05E0 F8                 1590 	mov	r0,a
   05E1 E6                 1591 	mov	a,@r0
   05E2 C0 E0              1592 	push	acc
   05E4 A8*00              1593 	mov	r0,_bp
   05E6 08                 1594 	inc	r0
   05E7 08                 1595 	inc	r0
   05E8 86 82              1596 	mov	dpl,@r0
   05EA 08                 1597 	inc	r0
   05EB 86 83              1598 	mov	dph,@r0
   05ED 08                 1599 	inc	r0
   05EE 86 F0              1600 	mov	b,@r0
   05F0 08                 1601 	inc	r0
   05F1 E6                 1602 	mov	a,@r0
   05F2 12s00rC0           1603 	lcall	_UART_TxDecimalNumber
   05F5 15 81              1604 	dec	sp
   05F7 D0 05              1605 	pop	ar5
   05F9 D0 04              1606 	pop	ar4
   05FB D0 03              1607 	pop	ar3
                           1608 ;	D:\Workspace\MIDE\firmware\/uart.c:538: break;	
   05FD 02s07rB3           1609 	ljmp	00134$
                           1610 ;	D:\Workspace\MIDE\firmware\/uart.c:540: case 'u':    /* Argument type is of unsigned integer, hence read 16bit unsigned data */
   0600                    1611 00117$:
                           1612 ;	D:\Workspace\MIDE\firmware\/uart.c:541: var_num_u16 = va_arg(argp, uint16_t);
   0600 C0 03              1613 	push	ar3
   0602 C0 04              1614 	push	ar4
   0604 C0 05              1615 	push	ar5
   0606 A9*00              1616 	mov	r1,_bp
   0608 09                 1617 	inc	r1
   0609 E7                 1618 	mov	a,@r1
   060A 24 FE              1619 	add	a,#0xfe
   060C F8                 1620 	mov	r0,a
   060D A9*00              1621 	mov	r1,_bp
   060F 09                 1622 	inc	r1
   0610 A7 00              1623 	mov	@r1,ar0
   0612 86 02              1624 	mov	ar2,@r0
   0614 08                 1625 	inc	r0
   0615 86 06              1626 	mov	ar6,@r0
   0617 18                 1627 	dec	r0
                           1628 ;	D:\Workspace\MIDE\firmware\/uart.c:543: UART_TxDecimalNumber(var_num_u16,var_numOfDigitsToTransmit_u8);
   0618 8A 07              1629 	mov	ar7,r2
   061A 8E 03              1630 	mov	ar3,r6
   061C 7C 00              1631 	mov	r4,#0x00
   061E 7D 00              1632 	mov	r5,#0x00
   0620 C0 03              1633 	push	ar3
   0622 C0 04              1634 	push	ar4
   0624 C0 05              1635 	push	ar5
   0626 E5*00              1636 	mov	a,_bp
   0628 24 0B              1637 	add	a,#0x0b
   062A F8                 1638 	mov	r0,a
   062B E6                 1639 	mov	a,@r0
   062C C0 E0              1640 	push	acc
   062E 8F 82              1641 	mov	dpl,r7
   0630 8B 83              1642 	mov	dph,r3
   0632 8C F0              1643 	mov	b,r4
   0634 ED                 1644 	mov	a,r5
   0635 12s00rC0           1645 	lcall	_UART_TxDecimalNumber
   0638 15 81              1646 	dec	sp
   063A D0 05              1647 	pop	ar5
   063C D0 04              1648 	pop	ar4
   063E D0 03              1649 	pop	ar3
                           1650 ;	D:\Workspace\MIDE\firmware\/uart.c:545: break;
   0640 D0 05              1651 	pop	ar5
   0642 D0 04              1652 	pop	ar4
   0644 D0 03              1653 	pop	ar3
   0646 02s07rB3           1654 	ljmp	00134$
                           1655 ;	D:\Workspace\MIDE\firmware\/uart.c:547: case 'U':    /* Argument type is of integer, hence read 32bit unsigend data */
   0649                    1656 00118$:
                           1657 ;	D:\Workspace\MIDE\firmware\/uart.c:548: var_num_u32 = va_arg(argp, uint32_t);
   0649 A9*00              1658 	mov	r1,_bp
   064B 09                 1659 	inc	r1
   064C E7                 1660 	mov	a,@r1
   064D 24 FC              1661 	add	a,#0xfc
   064F F8                 1662 	mov	r0,a
   0650 A9*00              1663 	mov	r1,_bp
   0652 09                 1664 	inc	r1
   0653 A7 00              1665 	mov	@r1,ar0
   0655 E5*00              1666 	mov	a,_bp
   0657 24 06              1667 	add	a,#0x06
   0659 F9                 1668 	mov	r1,a
   065A E6                 1669 	mov	a,@r0
   065B F7                 1670 	mov	@r1,a
   065C 08                 1671 	inc	r0
   065D E6                 1672 	mov	a,@r0
   065E 09                 1673 	inc	r1
   065F F7                 1674 	mov	@r1,a
   0660 08                 1675 	inc	r0
   0661 E6                 1676 	mov	a,@r0
   0662 09                 1677 	inc	r1
   0663 F7                 1678 	mov	@r1,a
   0664 08                 1679 	inc	r0
   0665 E6                 1680 	mov	a,@r0
   0666 09                 1681 	inc	r1
   0667 F7                 1682 	mov	@r1,a
   0668 18                 1683 	dec	r0
   0669 18                 1684 	dec	r0
   066A 18                 1685 	dec	r0
   066B E5*00              1686 	mov	a,_bp
   066D 24 06              1687 	add	a,#0x06
                           1688 ;	D:\Workspace\MIDE\firmware\/uart.c:550: UART_TxDecimalNumber(var_num_u32,var_numOfDigitsToTransmit_u8);
   066F C0 03              1689 	push	ar3
   0671 C0 04              1690 	push	ar4
   0673 C0 05              1691 	push	ar5
   0675 E5*00              1692 	mov	a,_bp
   0677 24 0B              1693 	add	a,#0x0b
   0679 F8                 1694 	mov	r0,a
   067A E6                 1695 	mov	a,@r0
   067B C0 E0              1696 	push	acc
   067D E5*00              1697 	mov	a,_bp
   067F 24 06              1698 	add	a,#0x06
   0681 F8                 1699 	mov	r0,a
   0682 86 82              1700 	mov	dpl,@r0
   0684 08                 1701 	inc	r0
   0685 86 83              1702 	mov	dph,@r0
   0687 08                 1703 	inc	r0
   0688 86 F0              1704 	mov	b,@r0
   068A 08                 1705 	inc	r0
   068B E6                 1706 	mov	a,@r0
   068C 12s00rC0           1707 	lcall	_UART_TxDecimalNumber
   068F 15 81              1708 	dec	sp
   0691 D0 05              1709 	pop	ar5
   0693 D0 04              1710 	pop	ar4
   0695 D0 03              1711 	pop	ar3
                           1712 ;	D:\Workspace\MIDE\firmware\/uart.c:552: break;			
   0697 02s07rB3           1713 	ljmp	00134$
                           1714 ;	D:\Workspace\MIDE\firmware\/uart.c:554: case 'x':  /* Argument type is of hex, hence hexadecimal data from the argp */
   069A                    1715 00119$:
                           1716 ;	D:\Workspace\MIDE\firmware\/uart.c:555: var_num_u16 = va_arg(argp, uint16_t);
   069A C0 03              1717 	push	ar3
   069C C0 04              1718 	push	ar4
   069E C0 05              1719 	push	ar5
   06A0 A9*00              1720 	mov	r1,_bp
   06A2 09                 1721 	inc	r1
   06A3 E7                 1722 	mov	a,@r1
   06A4 24 FE              1723 	add	a,#0xfe
   06A6 F8                 1724 	mov	r0,a
   06A7 A9*00              1725 	mov	r1,_bp
   06A9 09                 1726 	inc	r1
   06AA A7 00              1727 	mov	@r1,ar0
   06AC 86 07              1728 	mov	ar7,@r0
   06AE 08                 1729 	inc	r0
   06AF 86 03              1730 	mov	ar3,@r0
   06B1 18                 1731 	dec	r0
   06B2 8F 02              1732 	mov	ar2,r7
   06B4 8B 06              1733 	mov	ar6,r3
                           1734 ;	D:\Workspace\MIDE\firmware\/uart.c:557: UART_TxHexNumber(var_num_u16,var_numOfDigitsToTransmit_u8);
   06B6 7B 00              1735 	mov	r3,#0x00
   06B8 7C 00              1736 	mov	r4,#0x00
   06BA C0 03              1737 	push	ar3
   06BC C0 04              1738 	push	ar4
   06BE C0 05              1739 	push	ar5
   06C0 E5*00              1740 	mov	a,_bp
   06C2 24 0B              1741 	add	a,#0x0b
   06C4 F8                 1742 	mov	r0,a
   06C5 E6                 1743 	mov	a,@r0
   06C6 C0 E0              1744 	push	acc
   06C8 8A 82              1745 	mov	dpl,r2
   06CA 8E 83              1746 	mov	dph,r6
   06CC 8B F0              1747 	mov	b,r3
   06CE EC                 1748 	mov	a,r4
   06CF 12s02r18           1749 	lcall	_UART_TxHexNumber
   06D2 15 81              1750 	dec	sp
   06D4 D0 05              1751 	pop	ar5
   06D6 D0 04              1752 	pop	ar4
   06D8 D0 03              1753 	pop	ar3
                           1754 ;	D:\Workspace\MIDE\firmware\/uart.c:559: break;
   06DA D0 05              1755 	pop	ar5
   06DC D0 04              1756 	pop	ar4
   06DE D0 03              1757 	pop	ar3
   06E0 02s07rB3           1758 	ljmp	00134$
                           1759 ;	D:\Workspace\MIDE\firmware\/uart.c:561: case 'X':  /* Argument type is of hex, hence hexadecimal data from the argp */
   06E3                    1760 00120$:
                           1761 ;	D:\Workspace\MIDE\firmware\/uart.c:562: var_num_u32 = va_arg(argp, uint32_t);
   06E3 C0 03              1762 	push	ar3
   06E5 C0 04              1763 	push	ar4
   06E7 C0 05              1764 	push	ar5
   06E9 A9*00              1765 	mov	r1,_bp
   06EB 09                 1766 	inc	r1
   06EC E7                 1767 	mov	a,@r1
   06ED 24 FC              1768 	add	a,#0xfc
   06EF F8                 1769 	mov	r0,a
   06F0 A9*00              1770 	mov	r1,_bp
   06F2 09                 1771 	inc	r1
   06F3 A7 00              1772 	mov	@r1,ar0
   06F5 86 02              1773 	mov	ar2,@r0
   06F7 08                 1774 	inc	r0
   06F8 86 06              1775 	mov	ar6,@r0
   06FA 08                 1776 	inc	r0
   06FB 86 07              1777 	mov	ar7,@r0
   06FD 08                 1778 	inc	r0
   06FE 86 03              1779 	mov	ar3,@r0
   0700 18                 1780 	dec	r0
   0701 18                 1781 	dec	r0
   0702 18                 1782 	dec	r0
   0703 E5*00              1783 	mov	a,_bp
   0705 24 06              1784 	add	a,#0x06
   0707 F8                 1785 	mov	r0,a
   0708 A6 02              1786 	mov	@r0,ar2
   070A 08                 1787 	inc	r0
   070B A6 06              1788 	mov	@r0,ar6
   070D 08                 1789 	inc	r0
   070E A6 07              1790 	mov	@r0,ar7
   0710 08                 1791 	inc	r0
   0711 A6 03              1792 	mov	@r0,ar3
                           1793 ;	D:\Workspace\MIDE\firmware\/uart.c:564: UART_TxHexNumber(var_num_u32,var_numOfDigitsToTransmit_u8);
   0713 C0 03              1794 	push	ar3
   0715 C0 04              1795 	push	ar4
   0717 C0 05              1796 	push	ar5
   0719 E5*00              1797 	mov	a,_bp
   071B 24 0B              1798 	add	a,#0x0b
   071D F8                 1799 	mov	r0,a
   071E E6                 1800 	mov	a,@r0
   071F C0 E0              1801 	push	acc
   0721 E5*00              1802 	mov	a,_bp
   0723 24 06              1803 	add	a,#0x06
   0725 F8                 1804 	mov	r0,a
   0726 86 82              1805 	mov	dpl,@r0
   0728 08                 1806 	inc	r0
   0729 86 83              1807 	mov	dph,@r0
   072B 08                 1808 	inc	r0
   072C 86 F0              1809 	mov	b,@r0
   072E 08                 1810 	inc	r0
   072F E6                 1811 	mov	a,@r0
   0730 12s02r18           1812 	lcall	_UART_TxHexNumber
   0733 15 81              1813 	dec	sp
   0735 D0 05              1814 	pop	ar5
   0737 D0 04              1815 	pop	ar4
   0739 D0 03              1816 	pop	ar3
                           1817 ;	D:\Workspace\MIDE\firmware\/uart.c:566: break;
   073B D0 05              1818 	pop	ar5
   073D D0 04              1819 	pop	ar4
   073F D0 03              1820 	pop	ar3
                           1821 ;	D:\Workspace\MIDE\firmware\/uart.c:569: case 'b':  /* Argument type is of binary,Read int and convert to binary */
   0741 80 70              1822 	sjmp	00134$
   0743                    1823 00121$:
                           1824 ;	D:\Workspace\MIDE\firmware\/uart.c:570: var_num_u16 = va_arg(argp, uint16_t);
   0743 A8*00              1825 	mov	r0,_bp
   0745 08                 1826 	inc	r0
   0746 16                 1827 	dec	@r0
   0747 16                 1828 	dec	@r0
                           1829 ;	D:\Workspace\MIDE\firmware\/uart.c:576: break;
                           1830 ;	D:\Workspace\MIDE\firmware\/uart.c:578: case 'B':  /* Argument type is of binary,Read int and convert to binary */
   0748 80 69              1831 	sjmp	00134$
   074A                    1832 00122$:
                           1833 ;	D:\Workspace\MIDE\firmware\/uart.c:579: var_num_u32 = va_arg(argp, uint32_t);
   074A A8*00              1834 	mov	r0,_bp
   074C 08                 1835 	inc	r0
   074D 16                 1836 	dec	@r0
   074E 16                 1837 	dec	@r0
   074F 16                 1838 	dec	@r0
   0750 16                 1839 	dec	@r0
                           1840 ;	D:\Workspace\MIDE\firmware\/uart.c:585: break;
                           1841 ;	D:\Workspace\MIDE\firmware\/uart.c:589: case 'f': /* Argument type is of float, hence read double data from the argp */
   0751 80 60              1842 	sjmp	00134$
   0753                    1843 00124$:
                           1844 ;	D:\Workspace\MIDE\firmware\/uart.c:590: var_floatNum_f32 = va_arg(argp, double);
   0753 A8*00              1845 	mov	r0,_bp
   0755 08                 1846 	inc	r0
   0756 16                 1847 	dec	@r0
   0757 16                 1848 	dec	@r0
   0758 16                 1849 	dec	@r0
   0759 16                 1850 	dec	@r0
                           1851 ;	D:\Workspace\MIDE\firmware\/uart.c:594: break;
                           1852 ;	D:\Workspace\MIDE\firmware\/uart.c:598: case 's': /* Argument type is of string, hence get the pointer to sting passed */
   075A 80 57              1853 	sjmp	00134$
   075C                    1854 00126$:
                           1855 ;	D:\Workspace\MIDE\firmware\/uart.c:599: str = va_arg(argp, char *);
   075C A9*00              1856 	mov	r1,_bp
   075E 09                 1857 	inc	r1
   075F E7                 1858 	mov	a,@r1
   0760 24 FD              1859 	add	a,#0xfd
   0762 F8                 1860 	mov	r0,a
   0763 A9*00              1861 	mov	r1,_bp
   0765 09                 1862 	inc	r1
   0766 A7 00              1863 	mov	@r1,ar0
   0768 86 02              1864 	mov	ar2,@r0
   076A 08                 1865 	inc	r0
   076B 86 06              1866 	mov	ar6,@r0
   076D 08                 1867 	inc	r0
   076E 86 07              1868 	mov	ar7,@r0
   0770 18                 1869 	dec	r0
   0771 18                 1870 	dec	r0
                           1871 ;	D:\Workspace\MIDE\firmware\/uart.c:601: UART_TxString(str);
   0772 8A 82              1872 	mov	dpl,r2
   0774 8E 83              1873 	mov	dph,r6
   0776 8F F0              1874 	mov	b,r7
   0778 C0 03              1875 	push	ar3
   077A C0 04              1876 	push	ar4
   077C C0 05              1877 	push	ar5
   077E 12s00r95           1878 	lcall	_UART_TxString
   0781 D0 05              1879 	pop	ar5
   0783 D0 04              1880 	pop	ar4
   0785 D0 03              1881 	pop	ar3
                           1882 ;	D:\Workspace\MIDE\firmware\/uart.c:603: break;
                           1883 ;	D:\Workspace\MIDE\firmware\/uart.c:605: case '%':
   0787 80 2A              1884 	sjmp	00134$
   0789                    1885 00127$:
                           1886 ;	D:\Workspace\MIDE\firmware\/uart.c:606: UART_TxChar('%');
   0789 75 82 25           1887 	mov	dpl,#0x25
   078C C0 03              1888 	push	ar3
   078E C0 04              1889 	push	ar4
   0790 C0 05              1890 	push	ar5
   0792 12s00r8C           1891 	lcall	_UART_TxChar
   0795 D0 05              1892 	pop	ar5
   0797 D0 04              1893 	pop	ar4
   0799 D0 03              1894 	pop	ar3
                           1895 ;	D:\Workspace\MIDE\firmware\/uart.c:608: }
   079B 80 16              1896 	sjmp	00134$
   079D                    1897 00130$:
                           1898 ;	D:\Workspace\MIDE\firmware\/uart.c:613: UART_TxChar(ch);
   079D E5*00              1899 	mov	a,_bp
   079F 24 0A              1900 	add	a,#0x0a
   07A1 F8                 1901 	mov	r0,a
   07A2 86 82              1902 	mov	dpl,@r0
   07A4 C0 03              1903 	push	ar3
   07A6 C0 04              1904 	push	ar4
   07A8 C0 05              1905 	push	ar5
   07AA 12s00r8C           1906 	lcall	_UART_TxChar
   07AD D0 05              1907 	pop	ar5
   07AF D0 04              1908 	pop	ar4
   07B1 D0 03              1909 	pop	ar3
   07B3                    1910 00134$:
                           1911 ;	D:\Workspace\MIDE\firmware\/uart.c:484: for(ptr = argList; *ptr != '\0'; ptr++)
   07B3 0B                 1912 	inc	r3
   07B4 BB 00 01           1913 	cjne	r3,#0x00,00190$
   07B7 0C                 1914 	inc	r4
   07B8                    1915 00190$:
   07B8 02s03r55           1916 	ljmp	00132$
                           1917 ;	D:\Workspace\MIDE\firmware\/uart.c:617: va_end(argp);
   07BB                    1918 00136$:
   07BB 85*00 81           1919 	mov	sp,_bp
   07BE D0*00              1920 	pop	_bp
   07C0 22                 1921 	ret
                           1922 ;------------------------------------------------------------
                           1923 ;Allocation info for local variables in function 'RTC_Init'
                           1924 ;------------------------------------------------------------
                           1925 ;------------------------------------------------------------
                           1926 ;	D:\Workspace\MIDE\firmware\/rtc.c:57: void RTC_Init()
                           1927 ;	-----------------------------------------
                           1928 ;	 function RTC_Init
                           1929 ;	-----------------------------------------
   07C1                    1930 _RTC_Init:
                           1931 ;	D:\Workspace\MIDE\firmware\/rtc.c:59: I2C_Init();                             // Initialize the I2c module.
   07C1 12s09r8A           1932 	lcall	_I2C_Init
                           1933 ;	D:\Workspace\MIDE\firmware\/rtc.c:60: I2C_Start();                            // Start I2C communication
   07C4 12s09r8B           1934 	lcall	_I2C_Start
                           1935 ;	D:\Workspace\MIDE\firmware\/rtc.c:62: I2C_Write(C_Ds1307WriteMode_U8);        // Connect to DS1307 by sending its ID on I2c Bus
   07C7 75 82 D0           1936 	mov	dpl,#0xD0
   07CA 12s09rCC           1937 	lcall	_I2C_Write
                           1938 ;	D:\Workspace\MIDE\firmware\/rtc.c:63: I2C_Write(C_Ds1307ControlRegAddress_U8);// Select the Ds1307 ControlRegister to configure Ds1307
   07CD 75 82 07           1939 	mov	dpl,#0x07
   07D0 12s09rCC           1940 	lcall	_I2C_Write
                           1941 ;	D:\Workspace\MIDE\firmware\/rtc.c:65: I2C_Write(0x00);                        // Write 0x00 to Control register to disable SQW-Out
   07D3 75 82 00           1942 	mov	dpl,#0x00
   07D6 12s09rCC           1943 	lcall	_I2C_Write
                           1944 ;	D:\Workspace\MIDE\firmware\/rtc.c:67: I2C_Stop();                             // Stop I2C communication after initializing DS1307
   07D9 02s09rAD           1945 	ljmp	_I2C_Stop
                           1946 ;------------------------------------------------------------
                           1947 ;Allocation info for local variables in function 'RTC_SetTime'
                           1948 ;------------------------------------------------------------
                           1949 ;var_min_u8                Allocated to stack - offset -3
                           1950 ;var_sec_u8                Allocated to stack - offset -4
                           1951 ;var_hour_u8               Allocated to registers r2 
                           1952 ;------------------------------------------------------------
                           1953 ;	D:\Workspace\MIDE\firmware\/rtc.c:86: void RTC_SetTime(uint8_t var_hour_u8, uint8_t var_min_u8, uint8_t var_sec_u8)
                           1954 ;	-----------------------------------------
                           1955 ;	 function RTC_SetTime
                           1956 ;	-----------------------------------------
   07DC                    1957 _RTC_SetTime:
   07DC C0*00              1958 	push	_bp
   07DE 85 81*00           1959 	mov	_bp,sp
   07E1 AA 82              1960 	mov	r2,dpl
                           1961 ;	D:\Workspace\MIDE\firmware\/rtc.c:88: I2C_Start();                            // Start I2C communication
   07E3 C0 02              1962 	push	ar2
   07E5 12s09r8B           1963 	lcall	_I2C_Start
                           1964 ;	D:\Workspace\MIDE\firmware\/rtc.c:90: I2C_Write(C_Ds1307WriteMode_U8);        // connect to DS1307 by sending its ID on I2c Bus
   07E8 75 82 D0           1965 	mov	dpl,#0xD0
   07EB 12s09rCC           1966 	lcall	_I2C_Write
                           1967 ;	D:\Workspace\MIDE\firmware\/rtc.c:91: I2C_Write(C_Ds1307SecondRegAddress_U8); // Select the SEC RAM address
   07EE 75 82 00           1968 	mov	dpl,#0x00
   07F1 12s09rCC           1969 	lcall	_I2C_Write
                           1970 ;	D:\Workspace\MIDE\firmware\/rtc.c:93: I2C_Write(var_sec_u8);			        // Write sec from RAM address 00H
   07F4 E5*00              1971 	mov	a,_bp
   07F6 24 FC              1972 	add	a,#0xfc
   07F8 F8                 1973 	mov	r0,a
   07F9 86 82              1974 	mov	dpl,@r0
   07FB 12s09rCC           1975 	lcall	_I2C_Write
                           1976 ;	D:\Workspace\MIDE\firmware\/rtc.c:94: I2C_Write(var_min_u8);			        // Write min from RAM address 01H
   07FE E5*00              1977 	mov	a,_bp
   0800 24 FD              1978 	add	a,#0xfd
   0802 F8                 1979 	mov	r0,a
   0803 86 82              1980 	mov	dpl,@r0
   0805 12s09rCC           1981 	lcall	_I2C_Write
   0808 D0 02              1982 	pop	ar2
                           1983 ;	D:\Workspace\MIDE\firmware\/rtc.c:95: I2C_Write(var_hour_u8);			        // Write hour from RAM address 02H
   080A 8A 82              1984 	mov	dpl,r2
   080C 12s09rCC           1985 	lcall	_I2C_Write
                           1986 ;	D:\Workspace\MIDE\firmware\/rtc.c:97: I2C_Stop();           	                // Stop I2C communication after Setting the Time
   080F 12s09rAD           1987 	lcall	_I2C_Stop
   0812 D0*00              1988 	pop	_bp
   0814 22                 1989 	ret
                           1990 ;------------------------------------------------------------
                           1991 ;Allocation info for local variables in function 'RTC_SetDate'
                           1992 ;------------------------------------------------------------
                           1993 ;var_month_u8              Allocated to stack - offset -3
                           1994 ;var_year_u8               Allocated to stack - offset -4
                           1995 ;var_day_u8                Allocated to registers r2 
                           1996 ;------------------------------------------------------------
                           1997 ;	D:\Workspace\MIDE\firmware\/rtc.c:117: void RTC_SetDate(uint8_t var_day_u8, uint8_t var_month_u8, uint8_t var_year_u8)
                           1998 ;	-----------------------------------------
                           1999 ;	 function RTC_SetDate
                           2000 ;	-----------------------------------------
   0815                    2001 _RTC_SetDate:
   0815 C0*00              2002 	push	_bp
   0817 85 81*00           2003 	mov	_bp,sp
   081A AA 82              2004 	mov	r2,dpl
                           2005 ;	D:\Workspace\MIDE\firmware\/rtc.c:119: I2C_Start();                          // Start I2C communication
   081C C0 02              2006 	push	ar2
   081E 12s09r8B           2007 	lcall	_I2C_Start
                           2008 ;	D:\Workspace\MIDE\firmware\/rtc.c:121: I2C_Write(C_Ds1307WriteMode_U8);	  // connect to DS1307 by sending its ID on I2c Bus
   0821 75 82 D0           2009 	mov	dpl,#0xD0
   0824 12s09rCC           2010 	lcall	_I2C_Write
                           2011 ;	D:\Workspace\MIDE\firmware\/rtc.c:122: I2C_Write(C_Ds1307DateRegAddress_U8); // Request DAY RAM address at 04H
   0827 75 82 04           2012 	mov	dpl,#0x04
   082A 12s09rCC           2013 	lcall	_I2C_Write
   082D D0 02              2014 	pop	ar2
                           2015 ;	D:\Workspace\MIDE\firmware\/rtc.c:124: I2C_Write(var_day_u8);			      // Write date on RAM address 04H
   082F 8A 82              2016 	mov	dpl,r2
   0831 12s09rCC           2017 	lcall	_I2C_Write
                           2018 ;	D:\Workspace\MIDE\firmware\/rtc.c:125: I2C_Write(var_month_u8);			      // Write month on RAM address 05H
   0834 E5*00              2019 	mov	a,_bp
   0836 24 FD              2020 	add	a,#0xfd
   0838 F8                 2021 	mov	r0,a
   0839 86 82              2022 	mov	dpl,@r0
   083B 12s09rCC           2023 	lcall	_I2C_Write
                           2024 ;	D:\Workspace\MIDE\firmware\/rtc.c:126: I2C_Write(var_year_u8);			      // Write year on RAM address 06h
   083E E5*00              2025 	mov	a,_bp
   0840 24 FC              2026 	add	a,#0xfc
   0842 F8                 2027 	mov	r0,a
   0843 86 82              2028 	mov	dpl,@r0
   0845 12s09rCC           2029 	lcall	_I2C_Write
                           2030 ;	D:\Workspace\MIDE\firmware\/rtc.c:128: I2C_Stop();				              // Stop I2C communication after Setting the Date
   0848 12s09rAD           2031 	lcall	_I2C_Stop
   084B D0*00              2032 	pop	_bp
   084D 22                 2033 	ret
                           2034 ;------------------------------------------------------------
                           2035 ;Allocation info for local variables in function 'RTC_GetTime'
                           2036 ;------------------------------------------------------------
                           2037 ;ptr_min_u8                Allocated to stack - offset -5
                           2038 ;ptr_sec_u8                Allocated to stack - offset -8
                           2039 ;ptr_hour_u8               Allocated to stack - offset 1
                           2040 ;------------------------------------------------------------
                           2041 ;	D:\Workspace\MIDE\firmware\/rtc.c:147: void RTC_GetTime(uint8_t *ptr_hour_u8,uint8_t *ptr_min_u8,uint8_t *ptr_sec_u8)
                           2042 ;	-----------------------------------------
                           2043 ;	 function RTC_GetTime
                           2044 ;	-----------------------------------------
   084E                    2045 _RTC_GetTime:
   084E C0*00              2046 	push	_bp
   0850 85 81*00           2047 	mov	_bp,sp
   0853 C0 82              2048 	push	dpl
   0855 C0 83              2049 	push	dph
   0857 C0 F0              2050 	push	b
                           2051 ;	D:\Workspace\MIDE\firmware\/rtc.c:149: I2C_Start();                            // Start I2C communication
   0859 12s09r8B           2052 	lcall	_I2C_Start
                           2053 ;	D:\Workspace\MIDE\firmware\/rtc.c:151: I2C_Write(C_Ds1307WriteMode_U8);	    // connect to DS1307 by sending its ID on I2c Bus
   085C 75 82 D0           2054 	mov	dpl,#0xD0
   085F 12s09rCC           2055 	lcall	_I2C_Write
                           2056 ;	D:\Workspace\MIDE\firmware\/rtc.c:152: I2C_Write(C_Ds1307SecondRegAddress_U8); // Request Sec RAM address at 00H
   0862 75 82 00           2057 	mov	dpl,#0x00
   0865 12s09rCC           2058 	lcall	_I2C_Write
                           2059 ;	D:\Workspace\MIDE\firmware\/rtc.c:154: I2C_Stop();			                    // Stop I2C communication after selecting Sec Register
   0868 12s09rAD           2060 	lcall	_I2C_Stop
                           2061 ;	D:\Workspace\MIDE\firmware\/rtc.c:156: I2C_Start();		                    // Start I2C communication
   086B 12s09r8B           2062 	lcall	_I2C_Start
                           2063 ;	D:\Workspace\MIDE\firmware\/rtc.c:157: I2C_Write(C_Ds1307ReadMode_U8);	        // connect to DS1307(Read mode) by sending its ID
   086E 75 82 D1           2064 	mov	dpl,#0xD1
   0871 12s09rCC           2065 	lcall	_I2C_Write
                           2066 ;	D:\Workspace\MIDE\firmware\/rtc.c:159: *ptr_sec_u8 = I2C_Read(1);                // read second and return Positive ACK
   0874 E5*00              2067 	mov	a,_bp
   0876 24 F8              2068 	add	a,#0xf8
   0878 F8                 2069 	mov	r0,a
   0879 86 05              2070 	mov	ar5,@r0
   087B 08                 2071 	inc	r0
   087C 86 06              2072 	mov	ar6,@r0
   087E 08                 2073 	inc	r0
   087F 86 07              2074 	mov	ar7,@r0
   0881 75 82 01           2075 	mov	dpl,#0x01
   0884 C0 05              2076 	push	ar5
   0886 C0 06              2077 	push	ar6
   0888 C0 07              2078 	push	ar7
   088A 12s09rF8           2079 	lcall	_I2C_Read
   088D AA 82              2080 	mov	r2,dpl
   088F D0 07              2081 	pop	ar7
   0891 D0 06              2082 	pop	ar6
   0893 D0 05              2083 	pop	ar5
   0895 8D 82              2084 	mov	dpl,r5
   0897 8E 83              2085 	mov	dph,r6
   0899 8F F0              2086 	mov	b,r7
   089B EA                 2087 	mov	a,r2
   089C 12s00r00           2088 	lcall	__gptrput
                           2089 ;	D:\Workspace\MIDE\firmware\/rtc.c:160: *ptr_min_u8 = I2C_Read(1); 	            // read minute and return Positive ACK
   089F E5*00              2090 	mov	a,_bp
   08A1 24 FB              2091 	add	a,#0xfb
   08A3 F8                 2092 	mov	r0,a
   08A4 86 02              2093 	mov	ar2,@r0
   08A6 08                 2094 	inc	r0
   08A7 86 03              2095 	mov	ar3,@r0
   08A9 08                 2096 	inc	r0
   08AA 86 04              2097 	mov	ar4,@r0
   08AC 75 82 01           2098 	mov	dpl,#0x01
   08AF C0 02              2099 	push	ar2
   08B1 C0 03              2100 	push	ar3
   08B3 C0 04              2101 	push	ar4
   08B5 12s09rF8           2102 	lcall	_I2C_Read
   08B8 AD 82              2103 	mov	r5,dpl
   08BA D0 04              2104 	pop	ar4
   08BC D0 03              2105 	pop	ar3
   08BE D0 02              2106 	pop	ar2
   08C0 8A 82              2107 	mov	dpl,r2
   08C2 8B 83              2108 	mov	dph,r3
   08C4 8C F0              2109 	mov	b,r4
   08C6 ED                 2110 	mov	a,r5
   08C7 12s00r00           2111 	lcall	__gptrput
                           2112 ;	D:\Workspace\MIDE\firmware\/rtc.c:161: *ptr_hour_u8 = I2C_Read(0);               // read hour and return Negative/No ACK
   08CA 75 82 00           2113 	mov	dpl,#0x00
   08CD 12s09rF8           2114 	lcall	_I2C_Read
   08D0 AA 82              2115 	mov	r2,dpl
   08D2 A8*00              2116 	mov	r0,_bp
   08D4 08                 2117 	inc	r0
   08D5 86 82              2118 	mov	dpl,@r0
   08D7 08                 2119 	inc	r0
   08D8 86 83              2120 	mov	dph,@r0
   08DA 08                 2121 	inc	r0
   08DB 86 F0              2122 	mov	b,@r0
   08DD EA                 2123 	mov	a,r2
   08DE 12s00r00           2124 	lcall	__gptrput
                           2125 ;	D:\Workspace\MIDE\firmware\/rtc.c:163: I2C_Stop();		                        // Stop I2C communication after reading the Time
   08E1 12s09rAD           2126 	lcall	_I2C_Stop
   08E4 85*00 81           2127 	mov	sp,_bp
   08E7 D0*00              2128 	pop	_bp
   08E9 22                 2129 	ret
                           2130 ;------------------------------------------------------------
                           2131 ;Allocation info for local variables in function 'RTC_GetDate'
                           2132 ;------------------------------------------------------------
                           2133 ;ptr_month_u8              Allocated to stack - offset -5
                           2134 ;ptr_year_u8               Allocated to stack - offset -8
                           2135 ;ptr_day_u8                Allocated to registers r2 r3 r4 
                           2136 ;------------------------------------------------------------
                           2137 ;	D:\Workspace\MIDE\firmware\/rtc.c:183: void RTC_GetDate(uint8_t *ptr_day_u8,uint8_t *ptr_month_u8,uint8_t *ptr_year_u8)
                           2138 ;	-----------------------------------------
                           2139 ;	 function RTC_GetDate
                           2140 ;	-----------------------------------------
   08EA                    2141 _RTC_GetDate:
   08EA C0*00              2142 	push	_bp
   08EC 85 81*00           2143 	mov	_bp,sp
   08EF AA 82              2144 	mov	r2,dpl
   08F1 AB 83              2145 	mov	r3,dph
   08F3 AC F0              2146 	mov	r4,b
                           2147 ;	D:\Workspace\MIDE\firmware\/rtc.c:185: I2C_Start();                          // Start I2C communication
   08F5 C0 02              2148 	push	ar2
   08F7 C0 03              2149 	push	ar3
   08F9 C0 04              2150 	push	ar4
   08FB 12s09r8B           2151 	lcall	_I2C_Start
                           2152 ;	D:\Workspace\MIDE\firmware\/rtc.c:187: I2C_Write(C_Ds1307WriteMode_U8);	      // connect to DS1307 by sending its ID on I2c Bus
   08FE 75 82 D0           2153 	mov	dpl,#0xD0
   0901 12s09rCC           2154 	lcall	_I2C_Write
                           2155 ;	D:\Workspace\MIDE\firmware\/rtc.c:188: I2C_Write(C_Ds1307DateRegAddress_U8); // Request DAY RAM address at 04H
   0904 75 82 04           2156 	mov	dpl,#0x04
   0907 12s09rCC           2157 	lcall	_I2C_Write
                           2158 ;	D:\Workspace\MIDE\firmware\/rtc.c:190: I2C_Stop();			                  // Stop I2C communication after selecting DAY Register
   090A 12s09rAD           2159 	lcall	_I2C_Stop
                           2160 ;	D:\Workspace\MIDE\firmware\/rtc.c:193: I2C_Start();		                  // Start I2C communication
   090D 12s09r8B           2161 	lcall	_I2C_Start
                           2162 ;	D:\Workspace\MIDE\firmware\/rtc.c:194: I2C_Write(C_Ds1307ReadMode_U8);	      // connect to DS1307(Read mode) by sending its ID
   0910 75 82 D1           2163 	mov	dpl,#0xD1
   0913 12s09rCC           2164 	lcall	_I2C_Write
                           2165 ;	D:\Workspace\MIDE\firmware\/rtc.c:196: *ptr_day_u8 = I2C_Read(1);              // read Day and return Positive ACK
   0916 75 82 01           2166 	mov	dpl,#0x01
   0919 12s09rF8           2167 	lcall	_I2C_Read
   091C AD 82              2168 	mov	r5,dpl
   091E D0 04              2169 	pop	ar4
   0920 D0 03              2170 	pop	ar3
   0922 D0 02              2171 	pop	ar2
   0924 8A 82              2172 	mov	dpl,r2
   0926 8B 83              2173 	mov	dph,r3
   0928 8C F0              2174 	mov	b,r4
   092A ED                 2175 	mov	a,r5
   092B 12s00r00           2176 	lcall	__gptrput
                           2177 ;	D:\Workspace\MIDE\firmware\/rtc.c:197: *ptr_month_u8 = I2C_Read(1);            // read Month and return Positive ACK
   092E E5*00              2178 	mov	a,_bp
   0930 24 FB              2179 	add	a,#0xfb
   0932 F8                 2180 	mov	r0,a
   0933 86 02              2181 	mov	ar2,@r0
   0935 08                 2182 	inc	r0
   0936 86 03              2183 	mov	ar3,@r0
   0938 08                 2184 	inc	r0
   0939 86 04              2185 	mov	ar4,@r0
   093B 75 82 01           2186 	mov	dpl,#0x01
   093E C0 02              2187 	push	ar2
   0940 C0 03              2188 	push	ar3
   0942 C0 04              2189 	push	ar4
   0944 12s09rF8           2190 	lcall	_I2C_Read
   0947 AD 82              2191 	mov	r5,dpl
   0949 D0 04              2192 	pop	ar4
   094B D0 03              2193 	pop	ar3
   094D D0 02              2194 	pop	ar2
   094F 8A 82              2195 	mov	dpl,r2
   0951 8B 83              2196 	mov	dph,r3
   0953 8C F0              2197 	mov	b,r4
   0955 ED                 2198 	mov	a,r5
   0956 12s00r00           2199 	lcall	__gptrput
                           2200 ;	D:\Workspace\MIDE\firmware\/rtc.c:198: *ptr_year_u8 = I2C_Read(0);             // read Year and return Negative/No ACK
   0959 E5*00              2201 	mov	a,_bp
   095B 24 F8              2202 	add	a,#0xf8
   095D F8                 2203 	mov	r0,a
   095E 86 02              2204 	mov	ar2,@r0
   0960 08                 2205 	inc	r0
   0961 86 03              2206 	mov	ar3,@r0
   0963 08                 2207 	inc	r0
   0964 86 04              2208 	mov	ar4,@r0
   0966 75 82 00           2209 	mov	dpl,#0x00
   0969 C0 02              2210 	push	ar2
   096B C0 03              2211 	push	ar3
   096D C0 04              2212 	push	ar4
   096F 12s09rF8           2213 	lcall	_I2C_Read
   0972 AD 82              2214 	mov	r5,dpl
   0974 D0 04              2215 	pop	ar4
   0976 D0 03              2216 	pop	ar3
   0978 D0 02              2217 	pop	ar2
   097A 8A 82              2218 	mov	dpl,r2
   097C 8B 83              2219 	mov	dph,r3
   097E 8C F0              2220 	mov	b,r4
   0980 ED                 2221 	mov	a,r5
   0981 12s00r00           2222 	lcall	__gptrput
                           2223 ;	D:\Workspace\MIDE\firmware\/rtc.c:200: I2C_Stop();		                      // Stop I2C communication after reading the Date
   0984 12s09rAD           2224 	lcall	_I2C_Stop
   0987 D0*00              2225 	pop	_bp
   0989 22                 2226 	ret
                           2227 ;------------------------------------------------------------
                           2228 ;Allocation info for local variables in function 'I2C_Init'
                           2229 ;------------------------------------------------------------
                           2230 ;------------------------------------------------------------
                           2231 ;	D:\Workspace\MIDE\firmware\/i2c.c:16: void I2C_Init()
                           2232 ;	-----------------------------------------
                           2233 ;	 function I2C_Init
                           2234 ;	-----------------------------------------
   098A                    2235 _I2C_Init:
                           2236 ;	D:\Workspace\MIDE\firmware\/i2c.c:20: }
   098A 22                 2237 	ret
                           2238 ;------------------------------------------------------------
                           2239 ;Allocation info for local variables in function 'I2C_Start'
                           2240 ;------------------------------------------------------------
                           2241 ;------------------------------------------------------------
                           2242 ;	D:\Workspace\MIDE\firmware\/i2c.c:22: void I2C_Start()
                           2243 ;	-----------------------------------------
                           2244 ;	 function I2C_Start
                           2245 ;	-----------------------------------------
   098B                    2246 _I2C_Start:
                           2247 ;	D:\Workspace\MIDE\firmware\/i2c.c:26: util_BitClear(I2C_Port, SCL);        // Pull SCL low
   098B 53 80 BF           2248 	anl	_P0,#0xBF
                           2249 ;	D:\Workspace\MIDE\firmware\/i2c.c:27: util_BitSet(I2C_Port, SDA);       // Pull SDA High
   098E 43 80 80           2250 	orl	_P0,#0x80
                           2251 ;	D:\Workspace\MIDE\firmware\/i2c.c:28: DELAY_us(1);
   0991 90 00 01           2252 	mov	dptr,#0x0001
   0994 12s0CrC9           2253 	lcall	_DELAY_us
                           2254 ;	D:\Workspace\MIDE\firmware\/i2c.c:29: util_BitSet(I2C_Port, SCL);     //Pull SCL high
   0997 43 80 40           2255 	orl	_P0,#0x40
                           2256 ;	D:\Workspace\MIDE\firmware\/i2c.c:30: DELAY_us(1);
   099A 90 00 01           2257 	mov	dptr,#0x0001
   099D 12s0CrC9           2258 	lcall	_DELAY_us
                           2259 ;	D:\Workspace\MIDE\firmware\/i2c.c:31: util_BitClear(I2C_Port, SDA);      //Now Pull SDA LOW, to generate the Start Condition
   09A0 53 80 7F           2260 	anl	_P0,#0x7F
                           2261 ;	D:\Workspace\MIDE\firmware\/i2c.c:32: DELAY_us(1);
   09A3 90 00 01           2262 	mov	dptr,#0x0001
   09A6 12s0CrC9           2263 	lcall	_DELAY_us
                           2264 ;	D:\Workspace\MIDE\firmware\/i2c.c:33: util_BitClear(I2C_Port, SCL);        //Finally Clear the SCL to complete the cycle
   09A9 53 80 BF           2265 	anl	_P0,#0xBF
   09AC 22                 2266 	ret
                           2267 ;------------------------------------------------------------
                           2268 ;Allocation info for local variables in function 'I2C_Stop'
                           2269 ;------------------------------------------------------------
                           2270 ;------------------------------------------------------------
                           2271 ;	D:\Workspace\MIDE\firmware\/i2c.c:60: void I2C_Stop(void)
                           2272 ;	-----------------------------------------
                           2273 ;	 function I2C_Stop
                           2274 ;	-----------------------------------------
   09AD                    2275 _I2C_Stop:
                           2276 ;	D:\Workspace\MIDE\firmware\/i2c.c:63: util_BitClear(I2C_Port, SCL);            // Pull SCL low
   09AD 53 80 BF           2277 	anl	_P0,#0xBF
                           2278 ;	D:\Workspace\MIDE\firmware\/i2c.c:64: DELAY_us(1);
   09B0 90 00 01           2279 	mov	dptr,#0x0001
   09B3 12s0CrC9           2280 	lcall	_DELAY_us
                           2281 ;	D:\Workspace\MIDE\firmware\/i2c.c:65: util_BitClear(I2C_Port, SDA);          // Pull SDA  low
   09B6 53 80 7F           2282 	anl	_P0,#0x7F
                           2283 ;	D:\Workspace\MIDE\firmware\/i2c.c:66: DELAY_us(1);
   09B9 90 00 01           2284 	mov	dptr,#0x0001
   09BC 12s0CrC9           2285 	lcall	_DELAY_us
                           2286 ;	D:\Workspace\MIDE\firmware\/i2c.c:67: util_BitSet(I2C_Port, SCL);         // Pull SCL High
   09BF 43 80 40           2287 	orl	_P0,#0x40
                           2288 ;	D:\Workspace\MIDE\firmware\/i2c.c:68: DELAY_us(1);
   09C2 90 00 01           2289 	mov	dptr,#0x0001
   09C5 12s0CrC9           2290 	lcall	_DELAY_us
                           2291 ;	D:\Workspace\MIDE\firmware\/i2c.c:69: util_BitSet(I2C_Port, SDA);           // Now Pull SDA High, to generate the Stop Condition
   09C8 43 80 80           2292 	orl	_P0,#0x80
   09CB 22                 2293 	ret
                           2294 ;------------------------------------------------------------
                           2295 ;Allocation info for local variables in function 'I2C_Write'
                           2296 ;------------------------------------------------------------
                           2297 ;var_i2cData_u8            Allocated to registers r2 
                           2298 ;i                         Allocated to registers r3 
                           2299 ;------------------------------------------------------------
                           2300 ;	D:\Workspace\MIDE\firmware\/i2c.c:98: void I2C_Write(uint8_t var_i2cData_u8)
                           2301 ;	-----------------------------------------
                           2302 ;	 function I2C_Write
                           2303 ;	-----------------------------------------
   09CC                    2304 _I2C_Write:
   09CC AA 82              2305 	mov	r2,dpl
                           2306 ;	D:\Workspace\MIDE\firmware\/i2c.c:101: util_BitClear(I2C_Port,SDA); //output
   09CE 53 80 7F           2307 	anl	_P0,#0x7F
                           2308 ;	D:\Workspace\MIDE\firmware\/i2c.c:103: for(i=0;i<8;i++)                   // loop 8 times to send 1-byte of data
   09D1 7B 00              2309 	mov	r3,#0x00
   09D3                    2310 00104$:
   09D3 BB 08 00           2311 	cjne	r3,#0x08,00114$
   09D6                    2312 00114$:
   09D6 50 1D              2313 	jnc	00107$
                           2314 ;	D:\Workspace\MIDE\firmware\/i2c.c:105: if(util_IsBitSet(var_i2cData_u8,7))
   09D8 EA                 2315 	mov	a,r2
   09D9 30 E7 05           2316 	jnb	acc.7,00102$
                           2317 ;	D:\Workspace\MIDE\firmware\/i2c.c:107: util_BitSet(I2C_Port,SDA);
   09DC 43 80 80           2318 	orl	_P0,#0x80
   09DF 80 03              2319 	sjmp	00103$
   09E1                    2320 00102$:
                           2321 ;	D:\Workspace\MIDE\firmware\/i2c.c:111: util_BitClear(I2C_Port,SDA);
   09E1 53 80 7F           2322 	anl	_P0,#0x7F
   09E4                    2323 00103$:
                           2324 ;	D:\Workspace\MIDE\firmware\/i2c.c:115: i2c_Clock();                   // Generate Clock at SCL
   09E4 C0 02              2325 	push	ar2
   09E6 C0 03              2326 	push	ar3
   09E8 12s0Ar57           2327 	lcall	_i2c_Clock
   09EB D0 03              2328 	pop	ar3
   09ED D0 02              2329 	pop	ar2
                           2330 ;	D:\Workspace\MIDE\firmware\/i2c.c:116: var_i2cData_u8 = var_i2cData_u8<<1;// Bring the next bit to be transmitted to MSB position
   09EF EA                 2331 	mov	a,r2
   09F0 2A                 2332 	add	a,r2
   09F1 FA                 2333 	mov	r2,a
                           2334 ;	D:\Workspace\MIDE\firmware\/i2c.c:103: for(i=0;i<8;i++)                   // loop 8 times to send 1-byte of data
   09F2 0B                 2335 	inc	r3
   09F3 80 DE              2336 	sjmp	00104$
   09F5                    2337 00107$:
                           2338 ;	D:\Workspace\MIDE\firmware\/i2c.c:119: i2c_Clock();
   09F5 02s0Ar57           2339 	ljmp	_i2c_Clock
                           2340 ;------------------------------------------------------------
                           2341 ;Allocation info for local variables in function 'I2C_Read'
                           2342 ;------------------------------------------------------------
                           2343 ;var_ackOption_u8          Allocated to registers r2 
                           2344 ;i                         Allocated to registers r4 
                           2345 ;var_i2cData_u8            Allocated to registers r3 
                           2346 ;------------------------------------------------------------
                           2347 ;	D:\Workspace\MIDE\firmware\/i2c.c:146: uint8_t I2C_Read(uint8_t var_ackOption_u8)
                           2348 ;	-----------------------------------------
                           2349 ;	 function I2C_Read
                           2350 ;	-----------------------------------------
   09F8                    2351 _I2C_Read:
   09F8 AA 82              2352 	mov	r2,dpl
                           2353 ;	D:\Workspace\MIDE\firmware\/i2c.c:148: uint8_t i, var_i2cData_u8=0x00;
   09FA 7B 00              2354 	mov	r3,#0x00
                           2355 ;	D:\Workspace\MIDE\firmware\/i2c.c:150: util_BitSet(I2C_Port,SDA);              //Make SDA as I/P
   09FC 43 80 80           2356 	orl	_P0,#0x80
                           2357 ;	D:\Workspace\MIDE\firmware\/i2c.c:151: for(i=0;i<8;i++)     // loop 8times read 1-byte of data
   09FF 7C 00              2358 	mov	r4,#0x00
   0A01                    2359 00104$:
   0A01 BC 08 00           2360 	cjne	r4,#0x08,00114$
   0A04                    2361 00114$:
   0A04 50 3B              2362 	jnc	00107$
                           2363 ;	D:\Workspace\MIDE\firmware\/i2c.c:153: DELAY_us(1);
   0A06 90 00 01           2364 	mov	dptr,#0x0001
   0A09 C0 02              2365 	push	ar2
   0A0B C0 03              2366 	push	ar3
   0A0D C0 04              2367 	push	ar4
   0A0F 12s0CrC9           2368 	lcall	_DELAY_us
                           2369 ;	D:\Workspace\MIDE\firmware\/i2c.c:154: util_BitSet(I2C_Port, SCL);      // Pull SCL High
   0A12 43 80 40           2370 	orl	_P0,#0x40
                           2371 ;	D:\Workspace\MIDE\firmware\/i2c.c:155: DELAY_us(1);
   0A15 90 00 01           2372 	mov	dptr,#0x0001
   0A18 12s0CrC9           2373 	lcall	_DELAY_us
   0A1B D0 04              2374 	pop	ar4
   0A1D D0 03              2375 	pop	ar3
   0A1F D0 02              2376 	pop	ar2
                           2377 ;	D:\Workspace\MIDE\firmware\/i2c.c:157: var_i2cData_u8 = var_i2cData_u8<<1;    //var_i2cData_u8 is Shifted each time and
   0A21 EB                 2378 	mov	a,r3
   0A22 2B                 2379 	add	a,r3
   0A23 FB                 2380 	mov	r3,a
                           2381 ;	D:\Workspace\MIDE\firmware\/i2c.c:158: var_i2cData_u8 = var_i2cData_u8 | util_GetBitStatus(I2C_Port, SDA); //ORed with the received bit to pack into byte
   0A24 74 80              2382 	mov	a,#0x80
   0A26 55 80              2383 	anl	a,_P0
   0A28 FD                 2384 	mov	r5,a
   0A29 E4                 2385 	clr	a
   0A2A FE                 2386 	mov	r6,a
   0A2B BD 00 04           2387 	cjne	r5,#0x00,00116$
   0A2E BE 00 01           2388 	cjne	r6,#0x00,00116$
   0A31 04                 2389 	inc	a
   0A32                    2390 00116$:
   0A32 FD                 2391 	mov	r5,a
   0A33 B4 01 00           2392 	cjne	a,#0x01,00118$
   0A36                    2393 00118$:
   0A36 E4                 2394 	clr	a
   0A37 33                 2395 	rlc	a
   0A38 FD                 2396 	mov	r5,a
   0A39 42 03              2397 	orl	ar3,a
                           2398 ;	D:\Workspace\MIDE\firmware\/i2c.c:160: util_BitClear(I2C_Port, SCL);         // Clear SCL to complete the Clock
   0A3B 53 80 BF           2399 	anl	_P0,#0xBF
                           2400 ;	D:\Workspace\MIDE\firmware\/i2c.c:151: for(i=0;i<8;i++)     // loop 8times read 1-byte of data
   0A3E 0C                 2401 	inc	r4
   0A3F 80 C0              2402 	sjmp	00104$
   0A41                    2403 00107$:
                           2404 ;	D:\Workspace\MIDE\firmware\/i2c.c:162: if(var_ackOption_u8==1)  /*Send the Ack/NoAck depending on the user option*/
   0A41 BA 01 09           2405 	cjne	r2,#0x01,00102$
                           2406 ;	D:\Workspace\MIDE\firmware\/i2c.c:164: i2c_Ack();
   0A44 C0 03              2407 	push	ar3
   0A46 12s0Ar6A           2408 	lcall	_i2c_Ack
   0A49 D0 03              2409 	pop	ar3
   0A4B 80 07              2410 	sjmp	00103$
   0A4D                    2411 00102$:
                           2412 ;	D:\Workspace\MIDE\firmware\/i2c.c:168: i2c_NoAck();
   0A4D C0 03              2413 	push	ar3
   0A4F 12s0Ar74           2414 	lcall	_i2c_NoAck
   0A52 D0 03              2415 	pop	ar3
   0A54                    2416 00103$:
                           2417 ;	D:\Workspace\MIDE\firmware\/i2c.c:171: return var_i2cData_u8;           // Finally return the received Byte*
   0A54 8B 82              2418 	mov	dpl,r3
   0A56 22                 2419 	ret
                           2420 ;------------------------------------------------------------
                           2421 ;Allocation info for local variables in function 'i2c_Clock'
                           2422 ;------------------------------------------------------------
                           2423 ;------------------------------------------------------------
                           2424 ;	D:\Workspace\MIDE\firmware\/i2c.c:192: static void i2c_Clock(void)
                           2425 ;	-----------------------------------------
                           2426 ;	 function i2c_Clock
                           2427 ;	-----------------------------------------
   0A57                    2428 _i2c_Clock:
                           2429 ;	D:\Workspace\MIDE\firmware\/i2c.c:194: DELAY_us(1);
   0A57 90 00 01           2430 	mov	dptr,#0x0001
   0A5A 12s0CrC9           2431 	lcall	_DELAY_us
                           2432 ;	D:\Workspace\MIDE\firmware\/i2c.c:195: util_BitSet(I2C_Port, SCL);         // Wait for Some time and Pull the SCL line High
   0A5D 43 80 40           2433 	orl	_P0,#0x40
                           2434 ;	D:\Workspace\MIDE\firmware\/i2c.c:196: DELAY_us(1);        // Wait for Some time
   0A60 90 00 01           2435 	mov	dptr,#0x0001
   0A63 12s0CrC9           2436 	lcall	_DELAY_us
                           2437 ;	D:\Workspace\MIDE\firmware\/i2c.c:197: util_BitClear(I2C_Port, SCL);            // Pull back the SCL line low to Generate a clock pulse
   0A66 53 80 BF           2438 	anl	_P0,#0xBF
   0A69 22                 2439 	ret
                           2440 ;------------------------------------------------------------
                           2441 ;Allocation info for local variables in function 'i2c_Ack'
                           2442 ;------------------------------------------------------------
                           2443 ;------------------------------------------------------------
                           2444 ;	D:\Workspace\MIDE\firmware\/i2c.c:213: static void i2c_Ack()
                           2445 ;	-----------------------------------------
                           2446 ;	 function i2c_Ack
                           2447 ;	-----------------------------------------
   0A6A                    2448 _i2c_Ack:
                           2449 ;	D:\Workspace\MIDE\firmware\/i2c.c:215: util_BitClear(I2C_Port, SDA);      //Pull SDA low to indicate Positive ACK
   0A6A 53 80 7F           2450 	anl	_P0,#0x7F
                           2451 ;	D:\Workspace\MIDE\firmware\/i2c.c:216: i2c_Clock();    //Generate the Clock
   0A6D 12s0Ar57           2452 	lcall	_i2c_Clock
                           2453 ;	D:\Workspace\MIDE\firmware\/i2c.c:217: util_BitSet(I2C_Port, SDA);       // Pull SDA back to High(IDLE state)
   0A70 43 80 80           2454 	orl	_P0,#0x80
   0A73 22                 2455 	ret
                           2456 ;------------------------------------------------------------
                           2457 ;Allocation info for local variables in function 'i2c_NoAck'
                           2458 ;------------------------------------------------------------
                           2459 ;------------------------------------------------------------
                           2460 ;	D:\Workspace\MIDE\firmware\/i2c.c:233: static void i2c_NoAck()
                           2461 ;	-----------------------------------------
                           2462 ;	 function i2c_NoAck
                           2463 ;	-----------------------------------------
   0A74                    2464 _i2c_NoAck:
                           2465 ;	D:\Workspace\MIDE\firmware\/i2c.c:235: util_BitSet(I2C_Port, SDA);        //Pull SDA high to indicate Negative/NO ACK
   0A74 43 80 80           2466 	orl	_P0,#0x80
                           2467 ;	D:\Workspace\MIDE\firmware\/i2c.c:236: i2c_Clock();     // Generate the Clock  
   0A77 12s0Ar57           2468 	lcall	_i2c_Clock
                           2469 ;	D:\Workspace\MIDE\firmware\/i2c.c:237: util_BitSet(I2C_Port, SCL);      // Set SCL 
   0A7A 43 80 40           2470 	orl	_P0,#0x40
   0A7D 22                 2471 	ret
                           2472 ;------------------------------------------------------------
                           2473 ;Allocation info for local variables in function 'LCD_Init'
                           2474 ;------------------------------------------------------------
                           2475 ;var_lcdNoOfLines_u8       Allocated to stack - offset -3
                           2476 ;var_MaxCharsPerLine_u8    Allocated to stack - offset -4
                           2477 ;var_lcdMode_u8            Allocated to registers r2 
                           2478 ;------------------------------------------------------------
                           2479 ;	D:\Workspace\MIDE\firmware\/lcd.c:112: void LCD_Init(uint8_t var_lcdMode_u8, uint8_t var_lcdNoOfLines_u8, uint8_t var_MaxCharsPerLine_u8)
                           2480 ;	-----------------------------------------
                           2481 ;	 function LCD_Init
                           2482 ;	-----------------------------------------
   0A7E                    2483 _LCD_Init:
   0A7E C0*00              2484 	push	_bp
   0A80 85 81*00           2485 	mov	_bp,sp
   0A83 AA 82              2486 	mov	r2,dpl
                           2487 ;	D:\Workspace\MIDE\firmware\/lcd.c:116: M_LcdDataBusDirection = C_PortOutput_U8;     //Configure the Data Bus as output
   0A85 75 A0 00           2488 	mov	_P2,#0x00
                           2489 ;	D:\Workspace\MIDE\firmware\/lcd.c:117: M_LcdControlBusDirection = C_PortOutput_U8;  //Configure the Control Bus as output
   0A88 75 80 00           2490 	mov	_P0,#0x00
                           2491 ;	D:\Workspace\MIDE\firmware\/lcd.c:118: STK_LCDConfig.mvar_LcdMode_U8 = var_lcdMode_u8;      // Keep the track of selected Mode(4/8 bit)
   0A8B 8A*04              2492 	mov	(_STK_LCDConfig + 0x0002),r2
                           2493 ;	D:\Workspace\MIDE\firmware\/lcd.c:119: STK_LCDConfig.mvar_MaxSupportedChars_U8 = var_MaxCharsPerLine_u8; //Keep the LCD type
   0A8D E5*00              2494 	mov	a,_bp
   0A8F 24 FC              2495 	add	a,#0xfc
   0A91 F8                 2496 	mov	r0,a
   0A92 86*03              2497 	mov	(_STK_LCDConfig + 0x0001),@r0
                           2498 ;	D:\Workspace\MIDE\firmware\/lcd.c:120: STK_LCDConfig.mvar_MaxSupportedLines_U8 = var_lcdNoOfLines_u8;
   0A94 E5*00              2499 	mov	a,_bp
   0A96 24 FD              2500 	add	a,#0xfd
   0A98 F8                 2501 	mov	r0,a
   0A99 86*02              2502 	mov	_STK_LCDConfig,@r0
                           2503 ;	D:\Workspace\MIDE\firmware\/lcd.c:121: if(var_lcdNoOfLines_u8 > mENUM_LcdLineTwo)
   0A9B E5*00              2504 	mov	a,_bp
   0A9D 24 FD              2505 	add	a,#0xfd
   0A9F F8                 2506 	mov	r0,a
   0AA0 E6                 2507 	mov	a,@r0
   0AA1 24 FD              2508 	add	a,#0xff - 0x02
   0AA3 50 16              2509 	jnc	00102$
                           2510 ;	D:\Workspace\MIDE\firmware\/lcd.c:123: ARR_LcdLineNumAddress_U8[mENUM_LcdLineThree] =  0x90 + (var_MaxCharsPerLine_u8 & 0x0fu);
   0AA5 E5*00              2511 	mov	a,_bp
   0AA7 24 FC              2512 	add	a,#0xfc
   0AA9 F8                 2513 	mov	r0,a
   0AAA 86 02              2514 	mov	ar2,@r0
   0AAC 53 02 0F           2515 	anl	ar2,#0x0F
   0AAF 7B 00              2516 	mov	r3,#0x00
   0AB1 74 90              2517 	mov	a,#0x90
   0AB3 2A                 2518 	add	a,r2
   0AB4 F5*08              2519 	mov	(_ARR_LcdLineNumAddress_U8 + 0x0003),a
                           2520 ;	D:\Workspace\MIDE\firmware\/lcd.c:124: ARR_LcdLineNumAddress_U8[mENUM_LcdLineFour] =  0xd0 + (var_MaxCharsPerLine_u8 & 0x0fu);
   0AB6 74 D0              2521 	mov	a,#0xD0
   0AB8 2A                 2522 	add	a,r2
   0AB9 F5*09              2523 	mov	(_ARR_LcdLineNumAddress_U8 + 0x0004),a
   0ABB                    2524 00102$:
                           2525 ;	D:\Workspace\MIDE\firmware\/lcd.c:127: DELAY_ms(100);
   0ABB 90 00 64           2526 	mov	dptr,#0x0064
   0ABE 12s0CrD9           2527 	lcall	_DELAY_ms
                           2528 ;	D:\Workspace\MIDE\firmware\/lcd.c:129: if(STK_LCDConfig.mvar_LcdMode_U8 == M_EightBitMode)
   0AC1 AA*04              2529 	mov	r2,(_STK_LCDConfig + 0x0002)
   0AC3 7B 00              2530 	mov	r3,#0x00
   0AC5 BA 08 0B           2531 	cjne	r2,#0x08,00106$
   0AC8 BB 00 08           2532 	cjne	r3,#0x00,00106$
                           2533 ;	D:\Workspace\MIDE\firmware\/lcd.c:131: LCD_CmdWrite(CMD_LCD_EIGHT_BIT_MODE); // Initialize the LCD for 8-bit 5x7 matrix type
   0ACB 75 82 38           2534 	mov	dpl,#0x38
   0ACE 12s0Br2B           2535 	lcall	_LCD_CmdWrite
   0AD1 80 0F              2536 	sjmp	00107$
   0AD3                    2537 00106$:
                           2538 ;	D:\Workspace\MIDE\firmware\/lcd.c:133: else if(STK_LCDConfig.mvar_LcdMode_U8 == M_FourBitMode)
   0AD3 BA 04 0C           2539 	cjne	r2,#0x04,00107$
   0AD6 BB 00 09           2540 	cjne	r3,#0x00,00107$
                           2541 ;	D:\Workspace\MIDE\firmware\/lcd.c:135: lcd_Reset();
   0AD9 12s0Cr35           2542 	lcall	_lcd_Reset
                           2543 ;	D:\Workspace\MIDE\firmware\/lcd.c:136: LCD_CmdWrite(CMD_LCD_FOUR_BIT_MODE); // Initialize the LCD for 4-bit 5x7 matrix type 
   0ADC 75 82 28           2544 	mov	dpl,#0x28
   0ADF 12s0Br2B           2545 	lcall	_LCD_CmdWrite
   0AE2                    2546 00107$:
                           2547 ;	D:\Workspace\MIDE\firmware\/lcd.c:139: LCD_CmdWrite(CMD_DISPLAY_ON_CURSOR_ON);	 // Display ON cursor ON
   0AE2 75 82 0E           2548 	mov	dpl,#0x0E
   0AE5 12s0Br2B           2549 	lcall	_LCD_CmdWrite
                           2550 ;	D:\Workspace\MIDE\firmware\/lcd.c:140: LCD_Clear();	                         // Clear the LCD and go to First line First Position
   0AE8 12s0ArEE           2551 	lcall	_LCD_Clear
   0AEB D0*00              2552 	pop	_bp
   0AED 22                 2553 	ret
                           2554 ;------------------------------------------------------------
                           2555 ;Allocation info for local variables in function 'LCD_Clear'
                           2556 ;------------------------------------------------------------
                           2557 ;------------------------------------------------------------
                           2558 ;	D:\Workspace\MIDE\firmware\/lcd.c:154: void LCD_Clear()
                           2559 ;	-----------------------------------------
                           2560 ;	 function LCD_Clear
                           2561 ;	-----------------------------------------
   0AEE                    2562 _LCD_Clear:
                           2563 ;	D:\Workspace\MIDE\firmware\/lcd.c:156: LCD_CmdWrite(CMD_LCD_CLEAR);	// Clear the LCD and go to First line First Position
   0AEE 75 82 01           2564 	mov	dpl,#0x01
   0AF1 12s0Br2B           2565 	lcall	_LCD_CmdWrite
                           2566 ;	D:\Workspace\MIDE\firmware\/lcd.c:157: LCD_GoToLine(mENUM_LcdLineOne);
   0AF4 75 82 01           2567 	mov	dpl,#0x01
   0AF7 02s0ArFA           2568 	ljmp	_LCD_GoToLine
                           2569 ;------------------------------------------------------------
                           2570 ;Allocation info for local variables in function 'LCD_GoToLine'
                           2571 ;------------------------------------------------------------
                           2572 ;var_lineNumber_u8         Allocated to registers r2 
                           2573 ;------------------------------------------------------------
                           2574 ;	D:\Workspace\MIDE\firmware\/lcd.c:181: void LCD_GoToLine(uint8_t var_lineNumber_u8)
                           2575 ;	-----------------------------------------
                           2576 ;	 function LCD_GoToLine
                           2577 ;	-----------------------------------------
   0AFA                    2578 _LCD_GoToLine:
   0AFA AA 82              2579 	mov	r2,dpl
                           2580 ;	D:\Workspace\MIDE\firmware\/lcd.c:183: if(var_lineNumber_u8 <= STK_LCDConfig.mvar_MaxSupportedLines_U8)
   0AFC E5*02              2581 	mov	a,_STK_LCDConfig
   0AFE B5 02 00           2582 	cjne	a,ar2,00106$
   0B01                    2583 00106$:
   0B01 40 0E              2584 	jc	00103$
                           2585 ;	D:\Workspace\MIDE\firmware\/lcd.c:187: VAR_LcdTrackCursorPos_U8 = 0x00;
   0B03 75*01 00           2586 	mov	_VAR_LcdTrackCursorPos_U8,#0x00
                           2587 ;	D:\Workspace\MIDE\firmware\/lcd.c:188: VAR_LcdTrackLineNum_U8 = var_lineNumber_u8;
   0B06 8A*00              2588 	mov	_VAR_LcdTrackLineNum_U8,r2
                           2589 ;	D:\Workspace\MIDE\firmware\/lcd.c:189: LCD_CmdWrite(ARR_LcdLineNumAddress_U8[var_lineNumber_u8]);
   0B08 EA                 2590 	mov	a,r2
   0B09 24r05              2591 	add	a,#_ARR_LcdLineNumAddress_U8
   0B0B F8                 2592 	mov	r0,a
   0B0C 86 82              2593 	mov	dpl,@r0
   0B0E 02s0Br2B           2594 	ljmp	_LCD_CmdWrite
   0B11                    2595 00103$:
   0B11 22                 2596 	ret
                           2597 ;------------------------------------------------------------
                           2598 ;Allocation info for local variables in function 'LCD_GoToNextLine'
                           2599 ;------------------------------------------------------------
                           2600 ;------------------------------------------------------------
                           2601 ;	D:\Workspace\MIDE\firmware\/lcd.c:208: void  LCD_GoToNextLine()
                           2602 ;	-----------------------------------------
                           2603 ;	 function LCD_GoToNextLine
                           2604 ;	-----------------------------------------
   0B12                    2605 _LCD_GoToNextLine:
                           2606 ;	D:\Workspace\MIDE\firmware\/lcd.c:212: VAR_LcdTrackLineNum_U8++;
   0B12 05*00              2607 	inc	_VAR_LcdTrackLineNum_U8
                           2608 ;	D:\Workspace\MIDE\firmware\/lcd.c:213: VAR_LcdTrackCursorPos_U8 = 0x00;
   0B14 75*01 00           2609 	mov	_VAR_LcdTrackCursorPos_U8,#0x00
                           2610 ;	D:\Workspace\MIDE\firmware\/lcd.c:214: if(VAR_LcdTrackLineNum_U8 > STK_LCDConfig.mvar_MaxSupportedLines_U8)
   0B17 E5*02              2611 	mov	a,_STK_LCDConfig
   0B19 B5*00 00           2612 	cjne	a,_VAR_LcdTrackLineNum_U8,00106$
   0B1C                    2613 00106$:
   0B1C 50 03              2614 	jnc	00102$
                           2615 ;	D:\Workspace\MIDE\firmware\/lcd.c:215: VAR_LcdTrackLineNum_U8 = 0x01;
   0B1E 75*00 01           2616 	mov	_VAR_LcdTrackLineNum_U8,#0x01
   0B21                    2617 00102$:
                           2618 ;	D:\Workspace\MIDE\firmware\/lcd.c:216: LCD_CmdWrite(ARR_LcdLineNumAddress_U8[VAR_LcdTrackLineNum_U8]);
   0B21 E5*00              2619 	mov	a,_VAR_LcdTrackLineNum_U8
   0B23 24r05              2620 	add	a,#_ARR_LcdLineNumAddress_U8
   0B25 F8                 2621 	mov	r0,a
   0B26 86 82              2622 	mov	dpl,@r0
   0B28 02s0Br2B           2623 	ljmp	_LCD_CmdWrite
                           2624 ;------------------------------------------------------------
                           2625 ;Allocation info for local variables in function 'LCD_CmdWrite'
                           2626 ;------------------------------------------------------------
                           2627 ;var_lcdCmd_u8             Allocated to registers r2 
                           2628 ;------------------------------------------------------------
                           2629 ;	D:\Workspace\MIDE\firmware\/lcd.c:274: void LCD_CmdWrite( uint8_t var_lcdCmd_u8)
                           2630 ;	-----------------------------------------
                           2631 ;	 function LCD_CmdWrite
                           2632 ;	-----------------------------------------
   0B2B                    2633 _LCD_CmdWrite:
   0B2B AA 82              2634 	mov	r2,dpl
                           2635 ;	D:\Workspace\MIDE\firmware\/lcd.c:276: lcd_BusyCheck();
   0B2D C0 02              2636 	push	ar2
   0B2F 12s0BrE3           2637 	lcall	_lcd_BusyCheck
   0B32 D0 02              2638 	pop	ar2
                           2639 ;	D:\Workspace\MIDE\firmware\/lcd.c:277: if(STK_LCDConfig.mvar_LcdMode_U8 == M_EightBitMode)
   0B34 AB*04              2640 	mov	r3,(_STK_LCDConfig + 0x0002)
   0B36 7C 00              2641 	mov	r4,#0x00
   0B38 BB 08 08           2642 	cjne	r3,#0x08,00104$
   0B3B BC 00 05           2643 	cjne	r4,#0x00,00104$
                           2644 ;	D:\Workspace\MIDE\firmware\/lcd.c:280: M_LcdDataBus = var_lcdCmd_u8;     // Send the complete command if the selected mode is 8-bit
   0B3E 8A A0              2645 	mov	_P2,r2
                           2646 ;	D:\Workspace\MIDE\firmware\/lcd.c:281: lcd_SendCmdSignals();  // Signals for command write operation
   0B40 02s0CrA3           2647 	ljmp	_lcd_SendCmdSignals
   0B43                    2648 00104$:
                           2649 ;	D:\Workspace\MIDE\firmware\/lcd.c:283: else if(STK_LCDConfig.mvar_LcdMode_U8 == M_FourBitMode)
   0B43 BB 04 1B           2650 	cjne	r3,#0x04,00106$
   0B46 BC 00 18           2651 	cjne	r4,#0x00,00106$
                           2652 ;	D:\Workspace\MIDE\firmware\/lcd.c:285: lcd_SendNibble(var_lcdCmd_u8);  // Send the command in two nibbles as the selected mode is 4-bit
   0B49 8A 82              2653 	mov	dpl,r2
   0B4B C0 02              2654 	push	ar2
   0B4D 12s0Cr71           2655 	lcall	_lcd_SendNibble
                           2656 ;	D:\Workspace\MIDE\firmware\/lcd.c:286: lcd_SendCmdSignals(); // Signals for command write operation
   0B50 12s0CrA3           2657 	lcall	_lcd_SendCmdSignals
   0B53 D0 02              2658 	pop	ar2
                           2659 ;	D:\Workspace\MIDE\firmware\/lcd.c:288: lcd_SendNibble(var_lcdCmd_u8 << 4);
   0B55 EA                 2660 	mov	a,r2
   0B56 C4                 2661 	swap	a
   0B57 54 F0              2662 	anl	a,#0xf0
   0B59 F5 82              2663 	mov	dpl,a
   0B5B 12s0Cr71           2664 	lcall	_lcd_SendNibble
                           2665 ;	D:\Workspace\MIDE\firmware\/lcd.c:289: lcd_SendCmdSignals();
   0B5E 02s0CrA3           2666 	ljmp	_lcd_SendCmdSignals
   0B61                    2667 00106$:
   0B61 22                 2668 	ret
                           2669 ;------------------------------------------------------------
                           2670 ;Allocation info for local variables in function 'LCD_DisplayChar'
                           2671 ;------------------------------------------------------------
                           2672 ;var_lcdData_u8            Allocated to registers r2 
                           2673 ;------------------------------------------------------------
                           2674 ;	D:\Workspace\MIDE\firmware\/lcd.c:309: void LCD_DisplayChar(char var_lcdData_u8)
                           2675 ;	-----------------------------------------
                           2676 ;	 function LCD_DisplayChar
                           2677 ;	-----------------------------------------
   0B62                    2678 _LCD_DisplayChar:
   0B62 AA 82              2679 	mov	r2,dpl
                           2680 ;	D:\Workspace\MIDE\firmware\/lcd.c:311: if((VAR_LcdTrackCursorPos_U8>=STK_LCDConfig.mvar_MaxSupportedChars_U8) || (var_lcdData_u8=='\n'))
   0B64 E5*01              2681 	mov	a,_VAR_LcdTrackCursorPos_U8
   0B66 B5*03 00           2682 	cjne	a,(_STK_LCDConfig + 0x0001),00110$
   0B69                    2683 00110$:
   0B69 50 03              2684 	jnc	00101$
   0B6B BA 0A 07           2685 	cjne	r2,#0x0A,00102$
   0B6E                    2686 00101$:
                           2687 ;	D:\Workspace\MIDE\firmware\/lcd.c:315: LCD_GoToNextLine();
   0B6E C0 02              2688 	push	ar2
   0B70 12s0Br12           2689 	lcall	_LCD_GoToNextLine
   0B73 D0 02              2690 	pop	ar2
   0B75                    2691 00102$:
                           2692 ;	D:\Workspace\MIDE\firmware\/lcd.c:317: if(var_lcdData_u8!='\n') /* Display the character if its not newLine Char */
   0B75 BA 0A 01           2693 	cjne	r2,#0x0A,00114$
   0B78 22                 2694 	ret
   0B79                    2695 00114$:
                           2696 ;	D:\Workspace\MIDE\firmware\/lcd.c:320: lcd_DataWrite(var_lcdData_u8); /* Display the data and keep track of cursor */
   0B79 8A 82              2697 	mov	dpl,r2
   0B7B 12s0BrAC           2698 	lcall	_lcd_DataWrite
                           2699 ;	D:\Workspace\MIDE\firmware\/lcd.c:321: VAR_LcdTrackCursorPos_U8++;
   0B7E 05*01              2700 	inc	_VAR_LcdTrackCursorPos_U8
   0B80 22                 2701 	ret
                           2702 ;------------------------------------------------------------
                           2703 ;Allocation info for local variables in function 'LCD_DisplayString'
                           2704 ;------------------------------------------------------------
                           2705 ;ptr_stringPointer_u8      Allocated to registers r2 r3 r4 
                           2706 ;------------------------------------------------------------
                           2707 ;	D:\Workspace\MIDE\firmware\/lcd.c:344: void LCD_DisplayString(char *ptr_stringPointer_u8)
                           2708 ;	-----------------------------------------
                           2709 ;	 function LCD_DisplayString
                           2710 ;	-----------------------------------------
   0B81                    2711 _LCD_DisplayString:
   0B81 AA 82              2712 	mov	r2,dpl
   0B83 AB 83              2713 	mov	r3,dph
   0B85 AC F0              2714 	mov	r4,b
                           2715 ;	D:\Workspace\MIDE\firmware\/lcd.c:346: while((*ptr_stringPointer_u8)!=0)
   0B87                    2716 00101$:
   0B87 8A 82              2717 	mov	dpl,r2
   0B89 8B 83              2718 	mov	dph,r3
   0B8B 8C F0              2719 	mov	b,r4
   0B8D 12s00r00           2720 	lcall	__gptrget
   0B90 FD                 2721 	mov	r5,a
   0B91 60 18              2722 	jz	00104$
                           2723 ;	D:\Workspace\MIDE\firmware\/lcd.c:347: LCD_DisplayChar(*ptr_stringPointer_u8++); // Loop through the string and display char by char
   0B93 0A                 2724 	inc	r2
   0B94 BA 00 01           2725 	cjne	r2,#0x00,00110$
   0B97 0B                 2726 	inc	r3
   0B98                    2727 00110$:
   0B98 8D 82              2728 	mov	dpl,r5
   0B9A C0 02              2729 	push	ar2
   0B9C C0 03              2730 	push	ar3
   0B9E C0 04              2731 	push	ar4
   0BA0 12s0Br62           2732 	lcall	_LCD_DisplayChar
   0BA3 D0 04              2733 	pop	ar4
   0BA5 D0 03              2734 	pop	ar3
   0BA7 D0 02              2735 	pop	ar2
   0BA9 80 DC              2736 	sjmp	00101$
   0BAB                    2737 00104$:
   0BAB 22                 2738 	ret
                           2739 ;------------------------------------------------------------
                           2740 ;Allocation info for local variables in function 'lcd_DataWrite'
                           2741 ;------------------------------------------------------------
                           2742 ;dat                       Allocated to registers r2 
                           2743 ;------------------------------------------------------------
                           2744 ;	D:\Workspace\MIDE\firmware\/lcd.c:839: static void lcd_DataWrite( uint8_t dat)
                           2745 ;	-----------------------------------------
                           2746 ;	 function lcd_DataWrite
                           2747 ;	-----------------------------------------
   0BAC                    2748 _lcd_DataWrite:
   0BAC AA 82              2749 	mov	r2,dpl
                           2750 ;	D:\Workspace\MIDE\firmware\/lcd.c:841: lcd_BusyCheck();
   0BAE C0 02              2751 	push	ar2
   0BB0 12s0BrE3           2752 	lcall	_lcd_BusyCheck
   0BB3 D0 02              2753 	pop	ar2
                           2754 ;	D:\Workspace\MIDE\firmware\/lcd.c:842: if(STK_LCDConfig.mvar_LcdMode_U8 == M_EightBitMode)
   0BB5 AB*04              2755 	mov	r3,(_STK_LCDConfig + 0x0002)
   0BB7 7C 00              2756 	mov	r4,#0x00
   0BB9 BB 08 08           2757 	cjne	r3,#0x08,00104$
   0BBC BC 00 05           2758 	cjne	r4,#0x00,00104$
                           2759 ;	D:\Workspace\MIDE\firmware\/lcd.c:844: M_LcdDataBus = dat;      // Send the complete data byte if the selected mode is 8-bit
   0BBF 8A A0              2760 	mov	_P2,r2
                           2761 ;	D:\Workspace\MIDE\firmware\/lcd.c:845: lcd_SendDataSignals();  // Signals for data write operation
   0BC1 02s0CrB6           2762 	ljmp	_lcd_SendDataSignals
   0BC4                    2763 00104$:
                           2764 ;	D:\Workspace\MIDE\firmware\/lcd.c:847: else if(STK_LCDConfig.mvar_LcdMode_U8 == M_FourBitMode)
   0BC4 BB 04 1B           2765 	cjne	r3,#0x04,00106$
   0BC7 BC 00 18           2766 	cjne	r4,#0x00,00106$
                           2767 ;	D:\Workspace\MIDE\firmware\/lcd.c:849: lcd_SendNibble(dat);    // Send the data in two nibbles as the selected mode is 4-bit
   0BCA 8A 82              2768 	mov	dpl,r2
   0BCC C0 02              2769 	push	ar2
   0BCE 12s0Cr71           2770 	lcall	_lcd_SendNibble
                           2771 ;	D:\Workspace\MIDE\firmware\/lcd.c:850: lcd_SendDataSignals();  // Signals for data write operation
   0BD1 12s0CrB6           2772 	lcall	_lcd_SendDataSignals
   0BD4 D0 02              2773 	pop	ar2
                           2774 ;	D:\Workspace\MIDE\firmware\/lcd.c:852: lcd_SendNibble(dat << 4);
   0BD6 EA                 2775 	mov	a,r2
   0BD7 C4                 2776 	swap	a
   0BD8 54 F0              2777 	anl	a,#0xf0
   0BDA F5 82              2778 	mov	dpl,a
   0BDC 12s0Cr71           2779 	lcall	_lcd_SendNibble
                           2780 ;	D:\Workspace\MIDE\firmware\/lcd.c:853: lcd_SendDataSignals();
   0BDF 02s0CrB6           2781 	ljmp	_lcd_SendDataSignals
   0BE2                    2782 00106$:
   0BE2 22                 2783 	ret
                           2784 ;------------------------------------------------------------
                           2785 ;Allocation info for local variables in function 'lcd_BusyCheck'
                           2786 ;------------------------------------------------------------
                           2787 ;busyflag                  Allocated to registers r2 
                           2788 ;------------------------------------------------------------
                           2789 ;	D:\Workspace\MIDE\firmware\/lcd.c:873: static void lcd_BusyCheck()
                           2790 ;	-----------------------------------------
                           2791 ;	 function lcd_BusyCheck
                           2792 ;	-----------------------------------------
   0BE3                    2793 _lcd_BusyCheck:
                           2794 ;	D:\Workspace\MIDE\firmware\/lcd.c:878: util_UpdateBit(M_LcdDataBusDirection,LCD_D7,C_PinInput_U8); // Configure busy pin as input
   0BE3 43 A0 80           2795 	orl	_P2,#0x80
                           2796 ;	D:\Workspace\MIDE\firmware\/lcd.c:879: M_LcdClearBit(LCD_RS);           // Select the Command Register by pulling RS LOW
   0BE6 53 80 FE           2797 	anl	_P0,#0xFE
                           2798 ;	D:\Workspace\MIDE\firmware\/lcd.c:880: M_LcdSetBit(LCD_RW);             // Select the Read Operation for busy flag by setting RW
   0BE9 43 80 02           2799 	orl	_P0,#0x02
                           2800 ;	D:\Workspace\MIDE\firmware\/lcd.c:881: do
   0BEC                    2801 00103$:
                           2802 ;	D:\Workspace\MIDE\firmware\/lcd.c:884: M_LcdClearBit(LCD_EN);             // Send a High-to-Low Pulse at Enable Pin
   0BEC 53 80 FB           2803 	anl	_P0,#0xFB
                           2804 ;	D:\Workspace\MIDE\firmware\/lcd.c:885: DELAY_us(10);	
   0BEF 90 00 0A           2805 	mov	dptr,#0x000A
   0BF2 12s0CrC9           2806 	lcall	_DELAY_us
                           2807 ;	D:\Workspace\MIDE\firmware\/lcd.c:886: M_LcdSetBit(LCD_EN); 
   0BF5 43 80 04           2808 	orl	_P0,#0x04
                           2809 ;	D:\Workspace\MIDE\firmware\/lcd.c:887: DELAY_us(10);
   0BF8 90 00 0A           2810 	mov	dptr,#0x000A
   0BFB 12s0CrC9           2811 	lcall	_DELAY_us
                           2812 ;	D:\Workspace\MIDE\firmware\/lcd.c:888: busyflag = util_GetBitStatus(M_LcdDataBusInput,LCD_D7);
   0BFE 74 80              2813 	mov	a,#0x80
   0C00 55 A0              2814 	anl	a,_P2
   0C02 FA                 2815 	mov	r2,a
   0C03 E4                 2816 	clr	a
   0C04 FB                 2817 	mov	r3,a
   0C05 BA 00 04           2818 	cjne	r2,#0x00,00111$
   0C08 BB 00 01           2819 	cjne	r3,#0x00,00111$
   0C0B 04                 2820 	inc	a
   0C0C                    2821 00111$:
   0C0C FA                 2822 	mov	r2,a
   0C0D B4 01 00           2823 	cjne	a,#0x01,00113$
   0C10                    2824 00113$:
   0C10 E4                 2825 	clr	a
   0C11 33                 2826 	rlc	a
   0C12 FA                 2827 	mov	r2,a
                           2828 ;	D:\Workspace\MIDE\firmware\/lcd.c:891: if(STK_LCDConfig.mvar_LcdMode_U8 == 4)
   0C13 74 04              2829 	mov	a,#0x04
   0C15 B5*04 16           2830 	cjne	a,(_STK_LCDConfig + 0x0002),00104$
                           2831 ;	D:\Workspace\MIDE\firmware\/lcd.c:894: M_LcdClearBit(LCD_EN);
   0C18 53 80 FB           2832 	anl	_P0,#0xFB
                           2833 ;	D:\Workspace\MIDE\firmware\/lcd.c:895: DELAY_us(10);
   0C1B 90 00 0A           2834 	mov	dptr,#0x000A
   0C1E C0 02              2835 	push	ar2
   0C20 12s0CrC9           2836 	lcall	_DELAY_us
                           2837 ;	D:\Workspace\MIDE\firmware\/lcd.c:896: M_LcdSetBit(LCD_EN); 
   0C23 43 80 04           2838 	orl	_P0,#0x04
                           2839 ;	D:\Workspace\MIDE\firmware\/lcd.c:897: DELAY_us(10);
   0C26 90 00 0A           2840 	mov	dptr,#0x000A
   0C29 12s0CrC9           2841 	lcall	_DELAY_us
   0C2C D0 02              2842 	pop	ar2
   0C2E                    2843 00104$:
                           2844 ;	D:\Workspace\MIDE\firmware\/lcd.c:899: }while(busyflag);
   0C2E EA                 2845 	mov	a,r2
   0C2F 70 BB              2846 	jnz	00103$
                           2847 ;	D:\Workspace\MIDE\firmware\/lcd.c:901: util_UpdateBit(M_LcdDataBusDirection,LCD_D7,C_PinOutput_U8);
   0C31 53 A0 7F           2848 	anl	_P2,#0x7F
   0C34 22                 2849 	ret
                           2850 ;------------------------------------------------------------
                           2851 ;Allocation info for local variables in function 'lcd_Reset'
                           2852 ;------------------------------------------------------------
                           2853 ;------------------------------------------------------------
                           2854 ;	D:\Workspace\MIDE\firmware\/lcd.c:923: static void lcd_Reset()
                           2855 ;	-----------------------------------------
                           2856 ;	 function lcd_Reset
                           2857 ;	-----------------------------------------
   0C35                    2858 _lcd_Reset:
                           2859 ;	D:\Workspace\MIDE\firmware\/lcd.c:926: lcd_SendNibble(0x30);
   0C35 75 82 30           2860 	mov	dpl,#0x30
   0C38 12s0Cr71           2861 	lcall	_lcd_SendNibble
                           2862 ;	D:\Workspace\MIDE\firmware\/lcd.c:927: lcd_SendCmdSignals();
   0C3B 12s0CrA3           2863 	lcall	_lcd_SendCmdSignals
                           2864 ;	D:\Workspace\MIDE\firmware\/lcd.c:928: DELAY_ms(100);
   0C3E 90 00 64           2865 	mov	dptr,#0x0064
   0C41 12s0CrD9           2866 	lcall	_DELAY_ms
                           2867 ;	D:\Workspace\MIDE\firmware\/lcd.c:929: lcd_SendNibble(0x30);
   0C44 75 82 30           2868 	mov	dpl,#0x30
   0C47 12s0Cr71           2869 	lcall	_lcd_SendNibble
                           2870 ;	D:\Workspace\MIDE\firmware\/lcd.c:930: lcd_SendCmdSignals();
   0C4A 12s0CrA3           2871 	lcall	_lcd_SendCmdSignals
                           2872 ;	D:\Workspace\MIDE\firmware\/lcd.c:931: DELAY_us(200);
   0C4D 90 00 C8           2873 	mov	dptr,#0x00C8
   0C50 12s0CrC9           2874 	lcall	_DELAY_us
                           2875 ;	D:\Workspace\MIDE\firmware\/lcd.c:932: lcd_SendNibble(0x30);
   0C53 75 82 30           2876 	mov	dpl,#0x30
   0C56 12s0Cr71           2877 	lcall	_lcd_SendNibble
                           2878 ;	D:\Workspace\MIDE\firmware\/lcd.c:933: lcd_SendCmdSignals();
   0C59 12s0CrA3           2879 	lcall	_lcd_SendCmdSignals
                           2880 ;	D:\Workspace\MIDE\firmware\/lcd.c:934: DELAY_us(200);
   0C5C 90 00 C8           2881 	mov	dptr,#0x00C8
   0C5F 12s0CrC9           2882 	lcall	_DELAY_us
                           2883 ;	D:\Workspace\MIDE\firmware\/lcd.c:935: lcd_SendNibble(0x20);
   0C62 75 82 20           2884 	mov	dpl,#0x20
   0C65 12s0Cr71           2885 	lcall	_lcd_SendNibble
                           2886 ;	D:\Workspace\MIDE\firmware\/lcd.c:936: lcd_SendCmdSignals();
   0C68 12s0CrA3           2887 	lcall	_lcd_SendCmdSignals
                           2888 ;	D:\Workspace\MIDE\firmware\/lcd.c:937: DELAY_us(200);
   0C6B 90 00 C8           2889 	mov	dptr,#0x00C8
   0C6E 02s0CrC9           2890 	ljmp	_DELAY_us
                           2891 ;------------------------------------------------------------
                           2892 ;Allocation info for local variables in function 'lcd_SendNibble'
                           2893 ;------------------------------------------------------------
                           2894 ;var                       Allocated to registers r2 
                           2895 ;------------------------------------------------------------
                           2896 ;	D:\Workspace\MIDE\firmware\/lcd.c:953: static void lcd_SendNibble(uint8_t var)
                           2897 ;	-----------------------------------------
                           2898 ;	 function lcd_SendNibble
                           2899 ;	-----------------------------------------
   0C71                    2900 _lcd_SendNibble:
                           2901 ;	D:\Workspace\MIDE\firmware\/lcd.c:955: util_UpdateBit(M_LcdDataBus,LCD_D4,util_GetBitStatus(var,LCD_D4));
   0C71 E5 82              2902 	mov	a,dpl
   0C73 FA                 2903 	mov	r2,a
   0C74 30 E4 05           2904 	jnb	acc.4,00103$
   0C77 43 A0 10           2905 	orl	_P2,#0x10
   0C7A 80 03              2906 	sjmp	00104$
   0C7C                    2907 00103$:
   0C7C 53 A0 EF           2908 	anl	_P2,#0xEF
   0C7F                    2909 00104$:
                           2910 ;	D:\Workspace\MIDE\firmware\/lcd.c:956: util_UpdateBit(M_LcdDataBus,LCD_D5,util_GetBitStatus(var,LCD_D5));
   0C7F EA                 2911 	mov	a,r2
   0C80 30 E5 05           2912 	jnb	acc.5,00105$
   0C83 43 A0 20           2913 	orl	_P2,#0x20
   0C86 80 03              2914 	sjmp	00106$
   0C88                    2915 00105$:
   0C88 53 A0 DF           2916 	anl	_P2,#0xDF
   0C8B                    2917 00106$:
                           2918 ;	D:\Workspace\MIDE\firmware\/lcd.c:957: util_UpdateBit(M_LcdDataBus,LCD_D6,util_GetBitStatus(var,LCD_D6));
   0C8B EA                 2919 	mov	a,r2
   0C8C 30 E6 05           2920 	jnb	acc.6,00107$
   0C8F 43 A0 40           2921 	orl	_P2,#0x40
   0C92 80 03              2922 	sjmp	00108$
   0C94                    2923 00107$:
   0C94 53 A0 BF           2924 	anl	_P2,#0xBF
   0C97                    2925 00108$:
                           2926 ;	D:\Workspace\MIDE\firmware\/lcd.c:958: util_UpdateBit(M_LcdDataBus,LCD_D7,util_GetBitStatus(var,LCD_D7));
   0C97 EA                 2927 	mov	a,r2
   0C98 30 E7 04           2928 	jnb	acc.7,00109$
   0C9B 43 A0 80           2929 	orl	_P2,#0x80
   0C9E 22                 2930 	ret
   0C9F                    2931 00109$:
   0C9F 53 A0 7F           2932 	anl	_P2,#0x7F
   0CA2 22                 2933 	ret
                           2934 ;------------------------------------------------------------
                           2935 ;Allocation info for local variables in function 'lcd_SendCmdSignals'
                           2936 ;------------------------------------------------------------
                           2937 ;------------------------------------------------------------
                           2938 ;	D:\Workspace\MIDE\firmware\/lcd.c:972: static void lcd_SendCmdSignals()
                           2939 ;	-----------------------------------------
                           2940 ;	 function lcd_SendCmdSignals
                           2941 ;	-----------------------------------------
   0CA3                    2942 _lcd_SendCmdSignals:
                           2943 ;	D:\Workspace\MIDE\firmware\/lcd.c:974: M_LcdClearBit(LCD_RS);           // Select the Command Register by pulling RS LOW
   0CA3 53 80 FE           2944 	anl	_P0,#0xFE
                           2945 ;	D:\Workspace\MIDE\firmware\/lcd.c:976: M_LcdClearBit(LCD_RW);           // Select the Write Operation  by pulling RW LOW
   0CA6 53 80 FD           2946 	anl	_P0,#0xFD
                           2947 ;	D:\Workspace\MIDE\firmware\/lcd.c:978: M_LcdSetBit(LCD_EN);             // Send a High-to-Low Pusle at Enable Pin
   0CA9 43 80 04           2948 	orl	_P0,#0x04
                           2949 ;	D:\Workspace\MIDE\firmware\/lcd.c:979: DELAY_us(10);
   0CAC 90 00 0A           2950 	mov	dptr,#0x000A
   0CAF 12s0CrC9           2951 	lcall	_DELAY_us
                           2952 ;	D:\Workspace\MIDE\firmware\/lcd.c:980: M_LcdClearBit(LCD_EN);
   0CB2 53 80 FB           2953 	anl	_P0,#0xFB
   0CB5 22                 2954 	ret
                           2955 ;------------------------------------------------------------
                           2956 ;Allocation info for local variables in function 'lcd_SendDataSignals'
                           2957 ;------------------------------------------------------------
                           2958 ;------------------------------------------------------------
                           2959 ;	D:\Workspace\MIDE\firmware\/lcd.c:994: static void lcd_SendDataSignals()
                           2960 ;	-----------------------------------------
                           2961 ;	 function lcd_SendDataSignals
                           2962 ;	-----------------------------------------
   0CB6                    2963 _lcd_SendDataSignals:
                           2964 ;	D:\Workspace\MIDE\firmware\/lcd.c:996: M_LcdSetBit(LCD_RS); 			// Select the Data Register by pulling RS HIGH
   0CB6 43 80 01           2965 	orl	_P0,#0x01
                           2966 ;	D:\Workspace\MIDE\firmware\/lcd.c:998: M_LcdClearBit(LCD_RW);          // Select the Write Operation  by pulling RW LOW
   0CB9 53 80 FD           2967 	anl	_P0,#0xFD
                           2968 ;	D:\Workspace\MIDE\firmware\/lcd.c:1000: M_LcdSetBit(LCD_EN);            // Send a High-to-Low Pusle at Enable Pin
   0CBC 43 80 04           2969 	orl	_P0,#0x04
                           2970 ;	D:\Workspace\MIDE\firmware\/lcd.c:1001: DELAY_us(10);
   0CBF 90 00 0A           2971 	mov	dptr,#0x000A
   0CC2 12s0CrC9           2972 	lcall	_DELAY_us
                           2973 ;	D:\Workspace\MIDE\firmware\/lcd.c:1002: M_LcdClearBit(LCD_EN);
   0CC5 53 80 FB           2974 	anl	_P0,#0xFB
   0CC8 22                 2975 	ret
                           2976 ;------------------------------------------------------------
                           2977 ;Allocation info for local variables in function 'DELAY_us'
                           2978 ;------------------------------------------------------------
                           2979 ;us_count                  Allocated to registers r2 r3 
                           2980 ;------------------------------------------------------------
                           2981 ;	D:\Workspace\MIDE\firmware\/delay.c:55: void DELAY_us(uint16_t us_count)
                           2982 ;	-----------------------------------------
                           2983 ;	 function DELAY_us
                           2984 ;	-----------------------------------------
   0CC9                    2985 _DELAY_us:
   0CC9 AA 82              2986 	mov	r2,dpl
   0CCB AB 83              2987 	mov	r3,dph
                           2988 ;	D:\Workspace\MIDE\firmware\/delay.c:57: while(us_count!=0)
   0CCD                    2989 00101$:
   0CCD EA                 2990 	mov	a,r2
   0CCE 4B                 2991 	orl	a,r3
   0CCF 60 07              2992 	jz	00104$
                           2993 ;	D:\Workspace\MIDE\firmware\/delay.c:59: us_count--;
   0CD1 1A                 2994 	dec	r2
   0CD2 BA FF F8           2995 	cjne	r2,#0xff,00101$
   0CD5 1B                 2996 	dec	r3
   0CD6 80 F5              2997 	sjmp	00101$
   0CD8                    2998 00104$:
   0CD8 22                 2999 	ret
                           3000 ;------------------------------------------------------------
                           3001 ;Allocation info for local variables in function 'DELAY_ms'
                           3002 ;------------------------------------------------------------
                           3003 ;ms_count                  Allocated to registers r2 r3 
                           3004 ;------------------------------------------------------------
                           3005 ;	D:\Workspace\MIDE\firmware\/delay.c:76: void DELAY_ms(uint16_t ms_count)
                           3006 ;	-----------------------------------------
                           3007 ;	 function DELAY_ms
                           3008 ;	-----------------------------------------
   0CD9                    3009 _DELAY_ms:
   0CD9 AA 82              3010 	mov	r2,dpl
   0CDB AB 83              3011 	mov	r3,dph
                           3012 ;	D:\Workspace\MIDE\firmware\/delay.c:78: while(ms_count!=0)
   0CDD                    3013 00101$:
   0CDD EA                 3014 	mov	a,r2
   0CDE 4B                 3015 	orl	a,r3
   0CDF 60 15              3016 	jz	00104$
                           3017 ;	D:\Workspace\MIDE\firmware\/delay.c:80: DELAY_us(C_CountForOneMsDelay_U16);	 //DELAY_us is called to generate 1ms delay
   0CE1 90 00 70           3018 	mov	dptr,#0x0070
   0CE4 C0 02              3019 	push	ar2
   0CE6 C0 03              3020 	push	ar3
   0CE8 12s0CrC9           3021 	lcall	_DELAY_us
   0CEB D0 03              3022 	pop	ar3
   0CED D0 02              3023 	pop	ar2
                           3024 ;	D:\Workspace\MIDE\firmware\/delay.c:81: ms_count--;
   0CEF 1A                 3025 	dec	r2
   0CF0 BA FF EA           3026 	cjne	r2,#0xff,00101$
   0CF3 1B                 3027 	dec	r3
   0CF4 80 E7              3028 	sjmp	00101$
   0CF6                    3029 00104$:
   0CF6 22                 3030 	ret
                           3031 ;------------------------------------------------------------
                           3032 ;Allocation info for local variables in function 'DELAY_sec'
                           3033 ;------------------------------------------------------------
                           3034 ;sec_count                 Allocated to registers r2 r3 
                           3035 ;------------------------------------------------------------
                           3036 ;	D:\Workspace\MIDE\firmware\/delay.c:102: void DELAY_sec(uint16_t sec_count)
                           3037 ;	-----------------------------------------
                           3038 ;	 function DELAY_sec
                           3039 ;	-----------------------------------------
   0CF7                    3040 _DELAY_sec:
   0CF7 AA 82              3041 	mov	r2,dpl
   0CF9 AB 83              3042 	mov	r3,dph
                           3043 ;	D:\Workspace\MIDE\firmware\/delay.c:106: while(sec_count!=0)
   0CFB                    3044 00101$:
   0CFB EA                 3045 	mov	a,r2
   0CFC 4B                 3046 	orl	a,r3
   0CFD 60 15              3047 	jz	00104$
                           3048 ;	D:\Workspace\MIDE\firmware\/delay.c:108: DELAY_ms(1000);	//DELAY_ms is called to generate 1sec delay
   0CFF 90 03 E8           3049 	mov	dptr,#0x03E8
   0D02 C0 02              3050 	push	ar2
   0D04 C0 03              3051 	push	ar3
   0D06 12s0CrD9           3052 	lcall	_DELAY_ms
   0D09 D0 03              3053 	pop	ar3
   0D0B D0 02              3054 	pop	ar2
                           3055 ;	D:\Workspace\MIDE\firmware\/delay.c:109: sec_count--;
   0D0D 1A                 3056 	dec	r2
   0D0E BA FF EA           3057 	cjne	r2,#0xff,00101$
   0D11 1B                 3058 	dec	r3
   0D12 80 E7              3059 	sjmp	00101$
   0D14                    3060 00104$:
   0D14 22                 3061 	ret
                           3062 ;------------------------------------------------------------
                           3063 ;Allocation info for local variables in function 'ADC_Init'
                           3064 ;------------------------------------------------------------
                           3065 ;------------------------------------------------------------
                           3066 ;	D:\Workspace\MIDE\firmware\/adc.c:58: void ADC_Init()
                           3067 ;	-----------------------------------------
                           3068 ;	 function ADC_Init
                           3069 ;	-----------------------------------------
   0D15                    3070 _ADC_Init:
                           3071 ;	D:\Workspace\MIDE\firmware\/adc.c:60: util_BitClear(adc_controlbus,adc_Start); 
   0D15 53 80 EF           3072 	anl	_P0,#0xEF
                           3073 ;	D:\Workspace\MIDE\firmware\/adc.c:61: util_BitClear(adc_controlbus,adc_ALE); 
   0D18 53 80 F7           3074 	anl	_P0,#0xF7
                           3075 ;	D:\Workspace\MIDE\firmware\/adc.c:62: util_BitClear(adc_controlbus,adc_OE); 
   0D1B 53 80 BF           3076 	anl	_P0,#0xBF
                           3077 ;	D:\Workspace\MIDE\firmware\/adc.c:63: util_BitSet(adc_controlbus,adc_OE); 
   0D1E 43 80 40           3078 	orl	_P0,#0x40
                           3079 ;	D:\Workspace\MIDE\firmware\/adc.c:64: adc_databus=0xff; 
   0D21 75 90 FF           3080 	mov	_P1,#0xFF
   0D24 22                 3081 	ret
                           3082 ;------------------------------------------------------------
                           3083 ;Allocation info for local variables in function 'ADC_GetAdcValue'
                           3084 ;------------------------------------------------------------
                           3085 ;var_adcChannel_u8         Allocated to registers r2 
                           3086 ;adc_result                Allocated to registers r2 r3 
                           3087 ;------------------------------------------------------------
                           3088 ;	D:\Workspace\MIDE\firmware\/adc.c:111: uint16_t ADC_GetAdcValue(uint8_t var_adcChannel_u8)
                           3089 ;	-----------------------------------------
                           3090 ;	 function ADC_GetAdcValue
                           3091 ;	-----------------------------------------
   0D25                    3092 _ADC_GetAdcValue:
                           3093 ;	D:\Workspace\MIDE\firmware\/adc.c:119: util_UpdateBit(adc_controlbus,adc_A,util_GetBitStatus(var_adcChannel_u8,0X00)); 
   0D25 E5 82              3094 	mov	a,dpl
   0D27 FA                 3095 	mov	r2,a
   0D28 30 E0 05           3096 	jnb	acc.0,00106$
   0D2B 43 80 01           3097 	orl	_P0,#0x01
   0D2E 80 03              3098 	sjmp	00107$
   0D30                    3099 00106$:
   0D30 53 80 FE           3100 	anl	_P0,#0xFE
   0D33                    3101 00107$:
                           3102 ;	D:\Workspace\MIDE\firmware\/adc.c:120: util_UpdateBit(adc_controlbus,adc_B,util_GetBitStatus(var_adcChannel_u8,0X01));	
   0D33 EA                 3103 	mov	a,r2
   0D34 30 E1 05           3104 	jnb	acc.1,00108$
   0D37 43 80 02           3105 	orl	_P0,#0x02
   0D3A 80 03              3106 	sjmp	00109$
   0D3C                    3107 00108$:
   0D3C 53 80 FD           3108 	anl	_P0,#0xFD
   0D3F                    3109 00109$:
                           3110 ;	D:\Workspace\MIDE\firmware\/adc.c:121: util_UpdateBit(adc_controlbus,adc_C,util_GetBitStatus(var_adcChannel_u8,0X02));
   0D3F EA                 3111 	mov	a,r2
   0D40 30 E2 05           3112 	jnb	acc.2,00110$
   0D43 43 80 04           3113 	orl	_P0,#0x04
   0D46 80 03              3114 	sjmp	00111$
   0D48                    3115 00110$:
   0D48 53 80 FB           3116 	anl	_P0,#0xFB
   0D4B                    3117 00111$:
                           3118 ;	D:\Workspace\MIDE\firmware\/adc.c:124: util_BitSet(adc_controlbus,adc_ALE);        // Latch the address by making the ALE high.
   0D4B 43 80 08           3119 	orl	_P0,#0x08
                           3120 ;	D:\Workspace\MIDE\firmware\/adc.c:125: DELAY_us(50);
   0D4E 90 00 32           3121 	mov	dptr,#0x0032
   0D51 12s0CrC9           3122 	lcall	_DELAY_us
                           3123 ;	D:\Workspace\MIDE\firmware\/adc.c:126: util_BitSet(adc_controlbus,adc_Start);       //Start the conversion after latching the channel address
   0D54 43 80 10           3124 	orl	_P0,#0x10
                           3125 ;	D:\Workspace\MIDE\firmware\/adc.c:127: DELAY_us(25);
   0D57 90 00 19           3126 	mov	dptr,#0x0019
   0D5A 12s0CrC9           3127 	lcall	_DELAY_us
                           3128 ;	D:\Workspace\MIDE\firmware\/adc.c:129: util_BitClear(adc_controlbus,adc_ALE);          //Pull ALE line to zero after starting the conversion.
   0D5D 53 80 F7           3129 	anl	_P0,#0xF7
                           3130 ;	D:\Workspace\MIDE\firmware\/adc.c:130: DELAY_us(50);
   0D60 90 00 32           3131 	mov	dptr,#0x0032
   0D63 12s0CrC9           3132 	lcall	_DELAY_us
                           3133 ;	D:\Workspace\MIDE\firmware\/adc.c:131: util_BitClear(adc_controlbus,adc_Start);;       //Pull Start line to zero after starting the conversion.
   0D66 53 80 EF           3134 	anl	_P0,#0xEF
                           3135 ;	D:\Workspace\MIDE\firmware\/adc.c:134: while(util_GetBitStatus(adc_controlbus,adc_EOC)==0);    // Wait till the ADC conversion is completed,
   0D69                    3136 00101$:
   0D69 74 20              3137 	mov	a,#0x20
   0D6B 55 80              3138 	anl	a,_P0
   0D6D FA                 3139 	mov	r2,a
   0D6E 7B 00              3140 	mov	r3,#0x00
   0D70 BA 00 05           3141 	cjne	r2,#0x00,00120$
   0D73 BB 00 02           3142 	cjne	r3,#0x00,00120$
   0D76 80 F1              3143 	sjmp	00101$
   0D78                    3144 00120$:
                           3145 ;	D:\Workspace\MIDE\firmware\/adc.c:138: util_BitSet(adc_controlbus,adc_OE);          //Make the Output Enable high
   0D78 43 80 40           3146 	orl	_P0,#0x40
                           3147 ;	D:\Workspace\MIDE\firmware\/adc.c:140: DELAY_us(25);
   0D7B 90 00 19           3148 	mov	dptr,#0x0019
   0D7E 12s0CrC9           3149 	lcall	_DELAY_us
                           3150 ;	D:\Workspace\MIDE\firmware\/adc.c:141: adc_result=adc_databus;  //Read the ADC data from ADC bus
   0D81 AA 90              3151 	mov	r2,_P1
   0D83 7B 00              3152 	mov	r3,#0x00
                           3153 ;	D:\Workspace\MIDE\firmware\/adc.c:142: util_BitClear(adc_controlbus,adc_OE); 			  //After reading the data, disable th ADC output line.
   0D85 53 80 BF           3154 	anl	_P0,#0xBF
                           3155 ;	D:\Workspace\MIDE\firmware\/adc.c:144: return(adc_result) ;
   0D88 8A 82              3156 	mov	dpl,r2
   0D8A 8B 83              3157 	mov	dph,r3
   0D8C 22                 3158 	ret
                           3159 ;------------------------------------------------------------
                           3160 ;Allocation info for local variables in function 'KEYPAD_Init'
                           3161 ;------------------------------------------------------------
                           3162 ;------------------------------------------------------------
                           3163 ;	D:\Workspace\MIDE\firmware\/keypad.c:101: void KEYPAD_Init()
                           3164 ;	-----------------------------------------
                           3165 ;	 function KEYPAD_Init
                           3166 ;	-----------------------------------------
   0D8D                    3167 _KEYPAD_Init:
                           3168 ;	D:\Workspace\MIDE\firmware\/keypad.c:103: M_RowColDirection= C_RowOutputColInput_U8; // Configure Row lines as O/P and Column lines as I/P
   0D8D 75 A0 0F           3169 	mov	_P2,#0x0F
   0D90 22                 3170 	ret
                           3171 ;------------------------------------------------------------
                           3172 ;Allocation info for local variables in function 'KEYPAD_WaitForKeyRelease'
                           3173 ;------------------------------------------------------------
                           3174 ;key                       Allocated to registers r2 
                           3175 ;------------------------------------------------------------
                           3176 ;	D:\Workspace\MIDE\firmware\/keypad.c:118: void KEYPAD_WaitForKeyRelease()
                           3177 ;	-----------------------------------------
                           3178 ;	 function KEYPAD_WaitForKeyRelease
                           3179 ;	-----------------------------------------
   0D91                    3180 _KEYPAD_WaitForKeyRelease:
                           3181 ;	D:\Workspace\MIDE\firmware\/keypad.c:123: do
   0D91                    3182 00101$:
                           3183 ;	D:\Workspace\MIDE\firmware\/keypad.c:125: M_ROW=0x0F;           // Pull the ROW lines to low and Column lines high.
                           3184 ;	D:\Workspace\MIDE\firmware\/keypad.c:126: key=M_COL & 0x0F;     // Read the Columns, to check the key press
   0D91 74 0F              3185 	mov	a,#0x0F
   0D93 F5 A0              3186 	mov	_P2,a
   0D95 55 A0              3187 	anl	a,_P2
   0D97 FA                 3188 	mov	r2,a
                           3189 ;	D:\Workspace\MIDE\firmware\/keypad.c:127: }while(key!=0x0F);
   0D98 BA 0F F6           3190 	cjne	r2,#0x0F,00101$
                           3191 ;	D:\Workspace\MIDE\firmware\/keypad.c:129: DELAY_ms(1);
   0D9B 90 00 01           3192 	mov	dptr,#0x0001
   0D9E 12s0CrD9           3193 	lcall	_DELAY_ms
                           3194 ;	D:\Workspace\MIDE\firmware\/keypad.c:131: M_ROW=0x0F;           // Pull the ROW lines to low and Column lines high.
                           3195 ;	D:\Workspace\MIDE\firmware\/keypad.c:132: key=M_COL & 0x0F;     // Read the Columns, to check the key press
   0DA1 74 0F              3196 	mov	a,#0x0F
   0DA3 F5 A0              3197 	mov	_P2,a
   0DA5 55 A0              3198 	anl	a,_P2
   0DA7 FA                 3199 	mov	r2,a
                           3200 ;	D:\Workspace\MIDE\firmware\/keypad.c:133: }while(key!=0x0F);   // Wait till the Key is released,
   0DA8 BA 0F E6           3201 	cjne	r2,#0x0F,00101$
   0DAB 22                 3202 	ret
                           3203 ;------------------------------------------------------------
                           3204 ;Allocation info for local variables in function 'KEYPAD_WaitForKeyPress'
                           3205 ;------------------------------------------------------------
                           3206 ;var_keyPress_u8           Allocated to registers r2 
                           3207 ;------------------------------------------------------------
                           3208 ;	D:\Workspace\MIDE\firmware\/keypad.c:151: void KEYPAD_WaitForKeyPress()
                           3209 ;	-----------------------------------------
                           3210 ;	 function KEYPAD_WaitForKeyPress
                           3211 ;	-----------------------------------------
   0DAC                    3212 _KEYPAD_WaitForKeyPress:
                           3213 ;	D:\Workspace\MIDE\firmware\/keypad.c:156: do
   0DAC                    3214 00101$:
                           3215 ;	D:\Workspace\MIDE\firmware\/keypad.c:158: M_ROW=0x0F;		  // Pull the ROW lines to low and Column lines high.
                           3216 ;	D:\Workspace\MIDE\firmware\/keypad.c:159: var_keyPress_u8=M_COL & 0x0F;	  // Read the Columns, to check the key press
   0DAC 74 0F              3217 	mov	a,#0x0F
   0DAE F5 A0              3218 	mov	_P2,a
   0DB0 55 A0              3219 	anl	a,_P2
   0DB2 FA                 3220 	mov	r2,a
                           3221 ;	D:\Workspace\MIDE\firmware\/keypad.c:160: }while(var_keyPress_u8==0x0F); // Wait till the Key is pressed,
   0DB3 BA 0F 02           3222 	cjne	r2,#0x0F,00111$
   0DB6 80 F4              3223 	sjmp	00101$
   0DB8                    3224 00111$:
                           3225 ;	D:\Workspace\MIDE\firmware\/keypad.c:163: DELAY_ms(1);		  // Wait for some time(debounce Time);
   0DB8 90 00 01           3226 	mov	dptr,#0x0001
   0DBB 12s0CrD9           3227 	lcall	_DELAY_ms
                           3228 ;	D:\Workspace\MIDE\firmware\/keypad.c:165: M_ROW=0x0F;		  // After debounce time, perform the above operation
                           3229 ;	D:\Workspace\MIDE\firmware\/keypad.c:166: var_keyPress_u8=M_COL & 0x0F;	  // to ensure the Key press.
   0DBE 74 0F              3230 	mov	a,#0x0F
   0DC0 F5 A0              3231 	mov	_P2,a
   0DC2 55 A0              3232 	anl	a,_P2
   0DC4 FA                 3233 	mov	r2,a
                           3234 ;	D:\Workspace\MIDE\firmware\/keypad.c:168: }while(var_keyPress_u8==0x0F);
   0DC5 BA 0F 02           3235 	cjne	r2,#0x0F,00112$
   0DC8 80 E2              3236 	sjmp	00101$
   0DCA                    3237 00112$:
   0DCA 22                 3238 	ret
                           3239 ;------------------------------------------------------------
                           3240 ;Allocation info for local variables in function 'KEYPAD_GetKey'
                           3241 ;------------------------------------------------------------
                           3242 ;var_keyPress_u8           Allocated to registers r2 
                           3243 ;------------------------------------------------------------
                           3244 ;	D:\Workspace\MIDE\firmware\/keypad.c:194: uint8_t KEYPAD_GetKey()
                           3245 ;	-----------------------------------------
                           3246 ;	 function KEYPAD_GetKey
                           3247 ;	-----------------------------------------
   0DCB                    3248 _KEYPAD_GetKey:
                           3249 ;	D:\Workspace\MIDE\firmware\/keypad.c:198: KEYPAD_WaitForKeyRelease();    // Wait for the previous key release
   0DCB 12s0Dr91           3250 	lcall	_KEYPAD_WaitForKeyRelease
                           3251 ;	D:\Workspace\MIDE\firmware\/keypad.c:199: DELAY_ms(1);
   0DCE 90 00 01           3252 	mov	dptr,#0x0001
   0DD1 12s0CrD9           3253 	lcall	_DELAY_ms
                           3254 ;	D:\Workspace\MIDE\firmware\/keypad.c:201: KEYPAD_WaitForKeyPress();      // Wait for the new key press
   0DD4 12s0DrAC           3255 	lcall	_KEYPAD_WaitForKeyPress
                           3256 ;	D:\Workspace\MIDE\firmware\/keypad.c:202: var_keyPress_u8 = keypad_ScanKey();        // Scan for the key pressed.
   0DD7 12s0Er75           3257 	lcall	_keypad_ScanKey
   0DDA AA 82              3258 	mov	r2,dpl
                           3259 ;	D:\Workspace\MIDE\firmware\/keypad.c:204: switch(var_keyPress_u8)                       // Decode the key
   0DDC BA 77 03           3260 	cjne	r2,#0x77,00137$
   0DDF 02s0Er60           3261 	ljmp	00113$
   0DE2                    3262 00137$:
   0DE2 BA 7B 03           3263 	cjne	r2,#0x7B,00138$
   0DE5 02s0Er64           3264 	ljmp	00114$
   0DE8                    3265 00138$:
   0DE8 BA 7D 03           3266 	cjne	r2,#0x7D,00139$
   0DEB 02s0Er68           3267 	ljmp	00115$
   0DEE                    3268 00139$:
   0DEE BA 7E 03           3269 	cjne	r2,#0x7E,00140$
   0DF1 02s0Er6C           3270 	ljmp	00116$
   0DF4                    3271 00140$:
   0DF4 BA B7 02           3272 	cjne	r2,#0xB7,00141$
   0DF7 80 57              3273 	sjmp	00109$
   0DF9                    3274 00141$:
   0DF9 BA BB 02           3275 	cjne	r2,#0xBB,00142$
   0DFC 80 56              3276 	sjmp	00110$
   0DFE                    3277 00142$:
   0DFE BA BD 02           3278 	cjne	r2,#0xBD,00143$
   0E01 80 55              3279 	sjmp	00111$
   0E03                    3280 00143$:
   0E03 BA BE 02           3281 	cjne	r2,#0xBE,00144$
   0E06 80 54              3282 	sjmp	00112$
   0E08                    3283 00144$:
   0E08 BA D7 02           3284 	cjne	r2,#0xD7,00145$
   0E0B 80 33              3285 	sjmp	00105$
   0E0D                    3286 00145$:
   0E0D BA DB 02           3287 	cjne	r2,#0xDB,00146$
   0E10 80 32              3288 	sjmp	00106$
   0E12                    3289 00146$:
   0E12 BA DD 02           3290 	cjne	r2,#0xDD,00147$
   0E15 80 31              3291 	sjmp	00107$
   0E17                    3292 00147$:
   0E17 BA DE 02           3293 	cjne	r2,#0xDE,00148$
   0E1A 80 30              3294 	sjmp	00108$
   0E1C                    3295 00148$:
   0E1C BA E7 02           3296 	cjne	r2,#0xE7,00149$
   0E1F 80 0F              3297 	sjmp	00101$
   0E21                    3298 00149$:
   0E21 BA EB 02           3299 	cjne	r2,#0xEB,00150$
   0E24 80 0E              3300 	sjmp	00102$
   0E26                    3301 00150$:
   0E26 BA ED 02           3302 	cjne	r2,#0xED,00151$
   0E29 80 0D              3303 	sjmp	00103$
   0E2B                    3304 00151$:
                           3305 ;	D:\Workspace\MIDE\firmware\/keypad.c:206: case 0xe7: var_keyPress_u8='0'; break;
   0E2B BA EE 42           3306 	cjne	r2,#0xEE,00117$
   0E2E 80 0C              3307 	sjmp	00104$
   0E30                    3308 00101$:
   0E30 7A 30              3309 	mov	r2,#0x30
                           3310 ;	D:\Workspace\MIDE\firmware\/keypad.c:207: case 0xeb: var_keyPress_u8='1'; break;
   0E32 80 3E              3311 	sjmp	00118$
   0E34                    3312 00102$:
   0E34 7A 31              3313 	mov	r2,#0x31
                           3314 ;	D:\Workspace\MIDE\firmware\/keypad.c:208: case 0xed: var_keyPress_u8='2'; break;
   0E36 80 3A              3315 	sjmp	00118$
   0E38                    3316 00103$:
   0E38 7A 32              3317 	mov	r2,#0x32
                           3318 ;	D:\Workspace\MIDE\firmware\/keypad.c:209: case 0xee: var_keyPress_u8='3'; break;
   0E3A 80 36              3319 	sjmp	00118$
   0E3C                    3320 00104$:
   0E3C 7A 33              3321 	mov	r2,#0x33
                           3322 ;	D:\Workspace\MIDE\firmware\/keypad.c:210: case 0xd7: var_keyPress_u8='4'; break;
   0E3E 80 32              3323 	sjmp	00118$
   0E40                    3324 00105$:
   0E40 7A 34              3325 	mov	r2,#0x34
                           3326 ;	D:\Workspace\MIDE\firmware\/keypad.c:211: case 0xdb: var_keyPress_u8='5'; break;
   0E42 80 2E              3327 	sjmp	00118$
   0E44                    3328 00106$:
   0E44 7A 35              3329 	mov	r2,#0x35
                           3330 ;	D:\Workspace\MIDE\firmware\/keypad.c:212: case 0xdd: var_keyPress_u8='6'; break;
   0E46 80 2A              3331 	sjmp	00118$
   0E48                    3332 00107$:
   0E48 7A 36              3333 	mov	r2,#0x36
                           3334 ;	D:\Workspace\MIDE\firmware\/keypad.c:213: case 0xde: var_keyPress_u8='7'; break;
   0E4A 80 26              3335 	sjmp	00118$
   0E4C                    3336 00108$:
   0E4C 7A 37              3337 	mov	r2,#0x37
                           3338 ;	D:\Workspace\MIDE\firmware\/keypad.c:214: case 0xb7: var_keyPress_u8='8'; break;
   0E4E 80 22              3339 	sjmp	00118$
   0E50                    3340 00109$:
   0E50 7A 38              3341 	mov	r2,#0x38
                           3342 ;	D:\Workspace\MIDE\firmware\/keypad.c:215: case 0xbb: var_keyPress_u8='9'; break;
   0E52 80 1E              3343 	sjmp	00118$
   0E54                    3344 00110$:
   0E54 7A 39              3345 	mov	r2,#0x39
                           3346 ;	D:\Workspace\MIDE\firmware\/keypad.c:216: case 0xbd: var_keyPress_u8='A'; break;
   0E56 80 1A              3347 	sjmp	00118$
   0E58                    3348 00111$:
   0E58 7A 41              3349 	mov	r2,#0x41
                           3350 ;	D:\Workspace\MIDE\firmware\/keypad.c:217: case 0xbe: var_keyPress_u8='B'; break;
   0E5A 80 16              3351 	sjmp	00118$
   0E5C                    3352 00112$:
   0E5C 7A 42              3353 	mov	r2,#0x42
                           3354 ;	D:\Workspace\MIDE\firmware\/keypad.c:218: case 0x77: var_keyPress_u8='C'; break;
   0E5E 80 12              3355 	sjmp	00118$
   0E60                    3356 00113$:
   0E60 7A 43              3357 	mov	r2,#0x43
                           3358 ;	D:\Workspace\MIDE\firmware\/keypad.c:219: case 0x7b: var_keyPress_u8='D'; break;
   0E62 80 0E              3359 	sjmp	00118$
   0E64                    3360 00114$:
   0E64 7A 44              3361 	mov	r2,#0x44
                           3362 ;	D:\Workspace\MIDE\firmware\/keypad.c:220: case 0x7d: var_keyPress_u8='E'; break;
   0E66 80 0A              3363 	sjmp	00118$
   0E68                    3364 00115$:
   0E68 7A 45              3365 	mov	r2,#0x45
                           3366 ;	D:\Workspace\MIDE\firmware\/keypad.c:221: case 0x7e: var_keyPress_u8='F'; break;
   0E6A 80 06              3367 	sjmp	00118$
   0E6C                    3368 00116$:
   0E6C 7A 46              3369 	mov	r2,#0x46
                           3370 ;	D:\Workspace\MIDE\firmware\/keypad.c:222: default  : var_keyPress_u8='z'; break;
   0E6E 80 02              3371 	sjmp	00118$
   0E70                    3372 00117$:
   0E70 7A 7A              3373 	mov	r2,#0x7A
                           3374 ;	D:\Workspace\MIDE\firmware\/keypad.c:223: }
   0E72                    3375 00118$:
                           3376 ;	D:\Workspace\MIDE\firmware\/keypad.c:224: return(var_keyPress_u8);                      // Return the key
   0E72 8A 82              3377 	mov	dpl,r2
   0E74 22                 3378 	ret
                           3379 ;------------------------------------------------------------
                           3380 ;Allocation info for local variables in function 'keypad_ScanKey'
                           3381 ;------------------------------------------------------------
                           3382 ;var_keyScanCode_u8        Allocated to registers r2 
                           3383 ;i                         Allocated to registers r3 
                           3384 ;var_keyPress_u8           Allocated to stack - offset 1
                           3385 ;------------------------------------------------------------
                           3386 ;	D:\Workspace\MIDE\firmware\/keypad.c:246: static uint8_t keypad_ScanKey()
                           3387 ;	-----------------------------------------
                           3388 ;	 function keypad_ScanKey
                           3389 ;	-----------------------------------------
   0E75                    3390 _keypad_ScanKey:
   0E75 C0*00              3391 	push	_bp
   0E77 85 81*00           3392 	mov	_bp,sp
   0E7A 05 81              3393 	inc	sp
                           3394 ;	D:\Workspace\MIDE\firmware\/keypad.c:249: uint8_t var_keyScanCode_u8 = 0xEF,i, var_keyPress_u8;
   0E7C 7A EF              3395 	mov	r2,#0xEF
                           3396 ;	D:\Workspace\MIDE\firmware\/keypad.c:251: for(i=0;i<0x04;i++)                // Scan All the 4-Rows for key press
   0E7E 7B 00              3397 	mov	r3,#0x00
   0E80                    3398 00103$:
   0E80 BB 04 00           3399 	cjne	r3,#0x04,00113$
   0E83                    3400 00113$:
   0E83 50 20              3401 	jnc	00106$
                           3402 ;	D:\Workspace\MIDE\firmware\/keypad.c:253: M_ROW=var_keyScanCode_u8;        // Select 1-Row at a time for Scanning the Key
   0E85 8A A0              3403 	mov	_P2,r2
                           3404 ;	D:\Workspace\MIDE\firmware\/keypad.c:254: DELAY_ms(1);
   0E87 90 00 01           3405 	mov	dptr,#0x0001
   0E8A C0 02              3406 	push	ar2
   0E8C C0 03              3407 	push	ar3
   0E8E 12s0CrD9           3408 	lcall	_DELAY_ms
   0E91 D0 03              3409 	pop	ar3
   0E93 D0 02              3410 	pop	ar2
                           3411 ;	D:\Workspace\MIDE\firmware\/keypad.c:255: var_keyPress_u8=M_COL & 0x0F;    // Read the Column, for key press
   0E95 74 0F              3412 	mov	a,#0x0F
   0E97 55 A0              3413 	anl	a,_P2
   0E99 FD                 3414 	mov	r5,a
                           3415 ;	D:\Workspace\MIDE\firmware\/keypad.c:257: if(var_keyPress_u8!=0x0F)        // If the KEY press is detected for the selected
   0E9A BD 0F 08           3416 	cjne	r5,#0x0F,00106$
                           3417 ;	D:\Workspace\MIDE\firmware\/keypad.c:260: var_keyScanCode_u8=((var_keyScanCode_u8<<1)+0x01); // Rotate the ScanKey to SCAN the remaining Rows
   0E9D EA                 3418 	mov	a,r2
   0E9E 2A                 3419 	add	a,r2
   0E9F FC                 3420 	mov	r4,a
   0EA0 04                 3421 	inc	a
   0EA1 FA                 3422 	mov	r2,a
                           3423 ;	D:\Workspace\MIDE\firmware\/keypad.c:251: for(i=0;i<0x04;i++)                // Scan All the 4-Rows for key press
   0EA2 0B                 3424 	inc	r3
   0EA3 80 DB              3425 	sjmp	00103$
   0EA5                    3426 00106$:
                           3427 ;	D:\Workspace\MIDE\firmware\/keypad.c:262: var_keyPress_u8 = var_keyPress_u8 + (var_keyScanCode_u8 & 0xf0); // Return the row and COL status to decode the key
   0EA5 53 02 F0           3428 	anl	ar2,#0xF0
   0EA8 EA                 3429 	mov	a,r2
   0EA9 2D                 3430 	add	a,r5
                           3431 ;	D:\Workspace\MIDE\firmware\/keypad.c:263: return(var_keyPress_u8);
   0EAA F5 82              3432 	mov	dpl,a
   0EAC 85*00 81           3433 	mov	sp,_bp
   0EAF D0*00              3434 	pop	_bp
   0EB1 22                 3435 	ret
                           3436 ;------------------------------------------------------------
                           3437 ;Allocation info for local variables in function 'EEPROM_WriteByte'
                           3438 ;------------------------------------------------------------
                           3439 ;var_eepromData_u8         Allocated to stack - offset -3
                           3440 ;var_eepromAddress_u16     Allocated to registers r2 r3 
                           3441 ;var_eepromLowerAddress_u8 Allocated to registers r4 
                           3442 ;var_eepromHigherAddress_u8 Allocated to registers r2 
                           3443 ;var_eepromPageNumber_u8   Allocated to stack - offset 5
                           3444 ;var_eepromId_u8           Allocated to registers 
                           3445 ;------------------------------------------------------------
                           3446 ;	D:\Workspace\MIDE\firmware\/eeprom.c:94: void EEPROM_WriteByte(uint16_t var_eepromAddress_u16, uint8_t var_eepromData_u8)
                           3447 ;	-----------------------------------------
                           3448 ;	 function EEPROM_WriteByte
                           3449 ;	-----------------------------------------
   0EB2                    3450 _EEPROM_WriteByte:
   0EB2 C0*00              3451 	push	_bp
   0EB4 85 81*00           3452 	mov	_bp,sp
   0EB7 AA 82              3453 	mov	r2,dpl
   0EB9 AB 83              3454 	mov	r3,dph
                           3455 ;	D:\Workspace\MIDE\firmware\/eeprom.c:102: if(var_eepromAddress_u16 < C_MaxEepromSize_U16)	
   0EBB 74 F0              3456 	mov	a,#0x100 - 0x10
   0EBD 2B                 3457 	add	a,r3
   0EBE 40 36              3458 	jc	00103$
                           3459 ;	D:\Workspace\MIDE\firmware\/eeprom.c:104: var_eepromLowerAddress_u8 = util_ExtractByte0to8(var_eepromAddress_u16);
   0EC0 8A 04              3460 	mov	ar4,r2
                           3461 ;	D:\Workspace\MIDE\firmware\/eeprom.c:110: var_eepromHigherAddress_u8 = util_ExtractByte8to16(var_eepromAddress_u16);
   0EC2 8B 02              3462 	mov	ar2,r3
                           3463 ;	D:\Workspace\MIDE\firmware\/eeprom.c:113: I2C_Start();                       // Start i2c communication
   0EC4 C0 02              3464 	push	ar2
   0EC6 C0 04              3465 	push	ar4
   0EC8 12s09r8B           3466 	lcall	_I2C_Start
                           3467 ;	D:\Workspace\MIDE\firmware\/eeprom.c:115: I2C_Write(var_eepromId_u8); 
   0ECB 75 82 A0           3468 	mov	dpl,#0xA0
   0ECE 12s09rCC           3469 	lcall	_I2C_Write
   0ED1 D0 04              3470 	pop	ar4
   0ED3 D0 02              3471 	pop	ar2
                           3472 ;	D:\Workspace\MIDE\firmware\/eeprom.c:117: I2C_Write(var_eepromHigherAddress_u8);
   0ED5 8A 82              3473 	mov	dpl,r2
   0ED7 C0 04              3474 	push	ar4
   0ED9 12s09rCC           3475 	lcall	_I2C_Write
   0EDC D0 04              3476 	pop	ar4
                           3477 ;	D:\Workspace\MIDE\firmware\/eeprom.c:119: I2C_Write(var_eepromLowerAddress_u8); // Select the Specified EEPROM address of At24xx
   0EDE 8C 82              3478 	mov	dpl,r4
   0EE0 12s09rCC           3479 	lcall	_I2C_Write
                           3480 ;	D:\Workspace\MIDE\firmware\/eeprom.c:120: I2C_Write(var_eepromData_u8);         // Write the data at specified address
   0EE3 E5*00              3481 	mov	a,_bp
   0EE5 24 FD              3482 	add	a,#0xfd
   0EE7 F8                 3483 	mov	r0,a
   0EE8 86 82              3484 	mov	dpl,@r0
   0EEA 12s09rCC           3485 	lcall	_I2C_Write
                           3486 ;	D:\Workspace\MIDE\firmware\/eeprom.c:121: I2C_Stop();                           // Stop i2c communication after Writing the data
   0EED 12s09rAD           3487 	lcall	_I2C_Stop
                           3488 ;	D:\Workspace\MIDE\firmware\/eeprom.c:123: DELAY_ms(10);                         // Write operation takes max 5ms, refer At24xx data sheet 
   0EF0 90 00 0A           3489 	mov	dptr,#0x000A
   0EF3 12s0CrD9           3490 	lcall	_DELAY_ms
   0EF6                    3491 00103$:
   0EF6 D0*00              3492 	pop	_bp
   0EF8 22                 3493 	ret
                           3494 ;------------------------------------------------------------
                           3495 ;Allocation info for local variables in function 'EEPROM_ReadByte'
                           3496 ;------------------------------------------------------------
                           3497 ;var_eepromAddress_u16     Allocated to registers r2 r3 
                           3498 ;var_eepromLowerAddress_u8 Allocated to registers r5 
                           3499 ;var_eepromHigherAddress_u8 Allocated to registers r2 
                           3500 ;var_eepromPageNumber_u8   Allocated to stack - offset 5
                           3501 ;var_eepromData_u8         Allocated to registers r4 
                           3502 ;var_eepromId_u8           Allocated to registers 
                           3503 ;------------------------------------------------------------
                           3504 ;	D:\Workspace\MIDE\firmware\/eeprom.c:179: uint8_t EEPROM_ReadByte(uint16_t var_eepromAddress_u16)
                           3505 ;	-----------------------------------------
                           3506 ;	 function EEPROM_ReadByte
                           3507 ;	-----------------------------------------
   0EF9                    3508 _EEPROM_ReadByte:
   0EF9 AA 82              3509 	mov	r2,dpl
   0EFB AB 83              3510 	mov	r3,dph
                           3511 ;	D:\Workspace\MIDE\firmware\/eeprom.c:184: uint8_t var_eepromData_u8 = 0x00;
   0EFD 7C 00              3512 	mov	r4,#0x00
                           3513 ;	D:\Workspace\MIDE\firmware\/eeprom.c:187: if(var_eepromAddress_u16 < C_MaxEepromSize_U16)	
   0EFF 74 F0              3514 	mov	a,#0x100 - 0x10
   0F01 2B                 3515 	add	a,r3
   0F02 40 43              3516 	jc	00102$
                           3517 ;	D:\Workspace\MIDE\firmware\/eeprom.c:189: var_eepromLowerAddress_u8 = util_ExtractByte0to8(var_eepromAddress_u16);
   0F04 8A 05              3518 	mov	ar5,r2
                           3519 ;	D:\Workspace\MIDE\firmware\/eeprom.c:195: var_eepromHigherAddress_u8 = util_ExtractByte8to16(var_eepromAddress_u16);
   0F06 8B 02              3520 	mov	ar2,r3
                           3521 ;	D:\Workspace\MIDE\firmware\/eeprom.c:198: I2C_Start();                       // Start i2c communication
   0F08 C0 02              3522 	push	ar2
   0F0A C0 05              3523 	push	ar5
   0F0C 12s09r8B           3524 	lcall	_I2C_Start
                           3525 ;	D:\Workspace\MIDE\firmware\/eeprom.c:200: I2C_Write(var_eepromId_u8); 
   0F0F 75 82 A0           3526 	mov	dpl,#0xA0
   0F12 12s09rCC           3527 	lcall	_I2C_Write
   0F15 D0 05              3528 	pop	ar5
   0F17 D0 02              3529 	pop	ar2
                           3530 ;	D:\Workspace\MIDE\firmware\/eeprom.c:202: I2C_Write(var_eepromHigherAddress_u8);
   0F19 8A 82              3531 	mov	dpl,r2
   0F1B C0 05              3532 	push	ar5
   0F1D 12s09rCC           3533 	lcall	_I2C_Write
   0F20 D0 05              3534 	pop	ar5
                           3535 ;	D:\Workspace\MIDE\firmware\/eeprom.c:204: I2C_Write(var_eepromLowerAddress_u8); // Select the Specified EEPROM address of At24xx
   0F22 8D 82              3536 	mov	dpl,r5
   0F24 12s09rCC           3537 	lcall	_I2C_Write
                           3538 ;	D:\Workspace\MIDE\firmware\/eeprom.c:206: I2C_Start();                          // Start i2c communication after selecting the address
   0F27 12s09r8B           3539 	lcall	_I2C_Start
                           3540 ;	D:\Workspace\MIDE\firmware\/eeprom.c:207: I2C_Write(var_eepromId_u8 | 0x01);    // connect to At24xx(read) by sending its ID on I2c Bus
   0F2A 75 82 A1           3541 	mov	dpl,#0xA1
   0F2D 12s09rCC           3542 	lcall	_I2C_Write
                           3543 ;	D:\Workspace\MIDE\firmware\/eeprom.c:208: var_eepromData_u8 = I2C_Read(0);      // Read the data from specified address
   0F30 75 82 00           3544 	mov	dpl,#0x00
   0F33 12s09rF8           3545 	lcall	_I2C_Read
   0F36 AA 82              3546 	mov	r2,dpl
   0F38 8A 04              3547 	mov	ar4,r2
                           3548 ;	D:\Workspace\MIDE\firmware\/eeprom.c:209: I2C_Stop();                           // Stop i2c communication after Reading the data
   0F3A C0 04              3549 	push	ar4
   0F3C 12s09rAD           3550 	lcall	_I2C_Stop
                           3551 ;	D:\Workspace\MIDE\firmware\/eeprom.c:210: DELAY_us(10);
   0F3F 90 00 0A           3552 	mov	dptr,#0x000A
   0F42 12s0CrC9           3553 	lcall	_DELAY_us
   0F45 D0 04              3554 	pop	ar4
   0F47                    3555 00102$:
                           3556 ;	D:\Workspace\MIDE\firmware\/eeprom.c:213: return var_eepromData_u8;             // Return the data read from eeprom
   0F47 8C 82              3557 	mov	dpl,r4
   0F49 22                 3558 	ret
                           3559 ;------------------------------------------------------------
                           3560 ;Allocation info for local variables in function 'EEPROM_WriteString'
                           3561 ;------------------------------------------------------------
                           3562 ;ptr_stringPointer_u8      Allocated to stack - offset -5
                           3563 ;var_eepromAddress_u16     Allocated to registers r2 r3 
                           3564 ;sloc0                     Allocated to stack - offset 1
                           3565 ;------------------------------------------------------------
                           3566 ;	D:\Workspace\MIDE\firmware\/eeprom.c:297: void EEPROM_WriteString(uint16_t var_eepromAddress_u16, char *ptr_stringPointer_u8)
                           3567 ;	-----------------------------------------
                           3568 ;	 function EEPROM_WriteString
                           3569 ;	-----------------------------------------
   0F4A                    3570 _EEPROM_WriteString:
   0F4A C0*00              3571 	push	_bp
   0F4C 85 81*00           3572 	mov	_bp,sp
   0F4F 05 81              3573 	inc	sp
   0F51 05 81              3574 	inc	sp
   0F53 AA 82              3575 	mov	r2,dpl
   0F55 AB 83              3576 	mov	r3,dph
                           3577 ;	D:\Workspace\MIDE\firmware\/eeprom.c:300: do
   0F57 E5*00              3578 	mov	a,_bp
   0F59 24 FB              3579 	add	a,#0xfb
   0F5B F8                 3580 	mov	r0,a
   0F5C 86 04              3581 	mov	ar4,@r0
   0F5E 08                 3582 	inc	r0
   0F5F 86 05              3583 	mov	ar5,@r0
   0F61 08                 3584 	inc	r0
   0F62 86 06              3585 	mov	ar6,@r0
   0F64 A8*00              3586 	mov	r0,_bp
   0F66 08                 3587 	inc	r0
   0F67 A6 02              3588 	mov	@r0,ar2
   0F69 08                 3589 	inc	r0
   0F6A A6 03              3590 	mov	@r0,ar3
   0F6C                    3591 00101$:
                           3592 ;	D:\Workspace\MIDE\firmware\/eeprom.c:302: EEPROM_WriteByte(var_eepromAddress_u16,*ptr_stringPointer_u8); //Write a byte from RAM to EEPROM
   0F6C 8C 82              3593 	mov	dpl,r4
   0F6E 8D 83              3594 	mov	dph,r5
   0F70 8E F0              3595 	mov	b,r6
   0F72 12s00r00           3596 	lcall	__gptrget
   0F75 FF                 3597 	mov	r7,a
   0F76 A3                 3598 	inc	dptr
   0F77 AC 82              3599 	mov	r4,dpl
   0F79 AD 83              3600 	mov	r5,dph
   0F7B C0 04              3601 	push	ar4
   0F7D C0 05              3602 	push	ar5
   0F7F C0 06              3603 	push	ar6
   0F81 C0 07              3604 	push	ar7
   0F83 A8*00              3605 	mov	r0,_bp
   0F85 08                 3606 	inc	r0
   0F86 86 82              3607 	mov	dpl,@r0
   0F88 08                 3608 	inc	r0
   0F89 86 83              3609 	mov	dph,@r0
   0F8B 12s0ErB2           3610 	lcall	_EEPROM_WriteByte
   0F8E 15 81              3611 	dec	sp
   0F90 D0 06              3612 	pop	ar6
   0F92 D0 05              3613 	pop	ar5
   0F94 D0 04              3614 	pop	ar4
                           3615 ;	D:\Workspace\MIDE\firmware\/eeprom.c:303: ptr_stringPointer_u8++;								//Increment the RAM Address
                           3616 ;	D:\Workspace\MIDE\firmware\/eeprom.c:304: var_eepromAddress_u16++;								//Increment the Eeprom Address
   0F96 A8*00              3617 	mov	r0,_bp
   0F98 08                 3618 	inc	r0
   0F99 06                 3619 	inc	@r0
   0F9A B6 00 02           3620 	cjne	@r0,#0x00,00108$
   0F9D 08                 3621 	inc	r0
   0F9E 06                 3622 	inc	@r0
   0F9F                    3623 00108$:
                           3624 ;	D:\Workspace\MIDE\firmware\/eeprom.c:305: }while(*(ptr_stringPointer_u8-1) !=0);
   0F9F EC                 3625 	mov	a,r4
   0FA0 24 FF              3626 	add	a,#0xff
   0FA2 FF                 3627 	mov	r7,a
   0FA3 ED                 3628 	mov	a,r5
   0FA4 34 FF              3629 	addc	a,#0xff
   0FA6 FA                 3630 	mov	r2,a
   0FA7 8E 03              3631 	mov	ar3,r6
   0FA9 8F 82              3632 	mov	dpl,r7
   0FAB 8A 83              3633 	mov	dph,r2
   0FAD 8B F0              3634 	mov	b,r3
   0FAF 12s00r00           3635 	lcall	__gptrget
   0FB2 70 B8              3636 	jnz	00101$
   0FB4 85*00 81           3637 	mov	sp,_bp
   0FB7 D0*00              3638 	pop	_bp
   0FB9 22                 3639 	ret
                           3640 ;------------------------------------------------------------
                           3641 ;Allocation info for local variables in function 'EEPROM_ReadString'
                           3642 ;------------------------------------------------------------
                           3643 ;ptr_destStringAddress_u8  Allocated to stack - offset -5
                           3644 ;var_eepromAddress_u16     Allocated to registers r2 r3 
                           3645 ;eeprom_data               Allocated to registers r7 
                           3646 ;------------------------------------------------------------
                           3647 ;	D:\Workspace\MIDE\firmware\/eeprom.c:324: void EEPROM_ReadString(uint16_t var_eepromAddress_u16, char *ptr_destStringAddress_u8)
                           3648 ;	-----------------------------------------
                           3649 ;	 function EEPROM_ReadString
                           3650 ;	-----------------------------------------
   0FBA                    3651 _EEPROM_ReadString:
   0FBA C0*00              3652 	push	_bp
   0FBC 85 81*00           3653 	mov	_bp,sp
   0FBF AA 82              3654 	mov	r2,dpl
   0FC1 AB 83              3655 	mov	r3,dph
                           3656 ;	D:\Workspace\MIDE\firmware\/eeprom.c:328: do
   0FC3 E5*00              3657 	mov	a,_bp
   0FC5 24 FB              3658 	add	a,#0xfb
   0FC7 F8                 3659 	mov	r0,a
   0FC8 86 04              3660 	mov	ar4,@r0
   0FCA 08                 3661 	inc	r0
   0FCB 86 05              3662 	mov	ar5,@r0
   0FCD 08                 3663 	inc	r0
   0FCE 86 06              3664 	mov	ar6,@r0
   0FD0                    3665 00101$:
                           3666 ;	D:\Workspace\MIDE\firmware\/eeprom.c:330: eeprom_data = EEPROM_ReadByte(var_eepromAddress_u16); //Read a byte from EEPROM to RAM
   0FD0 8A 82              3667 	mov	dpl,r2
   0FD2 8B 83              3668 	mov	dph,r3
   0FD4 C0 02              3669 	push	ar2
   0FD6 C0 03              3670 	push	ar3
   0FD8 C0 04              3671 	push	ar4
   0FDA C0 05              3672 	push	ar5
   0FDC C0 06              3673 	push	ar6
   0FDE 12s0ErF9           3674 	lcall	_EEPROM_ReadByte
   0FE1 AF 82              3675 	mov	r7,dpl
   0FE3 D0 06              3676 	pop	ar6
   0FE5 D0 05              3677 	pop	ar5
   0FE7 D0 04              3678 	pop	ar4
   0FE9 D0 03              3679 	pop	ar3
   0FEB D0 02              3680 	pop	ar2
                           3681 ;	D:\Workspace\MIDE\firmware\/eeprom.c:331: *ptr_destStringAddress_u8 = eeprom_data;			 //Copy the data into String Buffer
   0FED 8C 82              3682 	mov	dpl,r4
   0FEF 8D 83              3683 	mov	dph,r5
   0FF1 8E F0              3684 	mov	b,r6
   0FF3 EF                 3685 	mov	a,r7
   0FF4 12s00r00           3686 	lcall	__gptrput
   0FF7 A3                 3687 	inc	dptr
   0FF8 AC 82              3688 	mov	r4,dpl
   0FFA AD 83              3689 	mov	r5,dph
                           3690 ;	D:\Workspace\MIDE\firmware\/eeprom.c:332: ptr_destStringAddress_u8++;						 //Increment the RAM Address
                           3691 ;	D:\Workspace\MIDE\firmware\/eeprom.c:333: var_eepromAddress_u16++;							 //Increment the Eeprom Address
   0FFC 0A                 3692 	inc	r2
   0FFD BA 00 01           3693 	cjne	r2,#0x00,00108$
   1000 0B                 3694 	inc	r3
   1001                    3695 00108$:
                           3696 ;	D:\Workspace\MIDE\firmware\/eeprom.c:334: }while(eeprom_data!=0);
   1001 EF                 3697 	mov	a,r7
   1002 70 CC              3698 	jnz	00101$
   1004 D0*00              3699 	pop	_bp
   1006 22                 3700 	ret
                           3701 ;------------------------------------------------------------
                           3702 ;Allocation info for local variables in function 'main'
                           3703 ;------------------------------------------------------------
                           3704 ;------------------------------------------------------------
                           3705 ;	D:\Workspace\MIDE\firmware\main.c:50: void main() 
                           3706 ;	-----------------------------------------
                           3707 ;	 function main
                           3708 ;	-----------------------------------------
   1007                    3709 _main:
                           3710 ;	D:\Workspace\MIDE\firmware\main.c:52: UART_Init(9600);
   1007 90 25 80           3711 	mov	dptr,#0x2580
   100A E4                 3712 	clr	a
   100B F5 F0              3713 	mov	b,a
   100D 12s00r00           3714 	lcall	_UART_Init
                           3715 ;	D:\Workspace\MIDE\firmware\main.c:53: UART_TxString("\n\rTest menu Utra x51 v1.1\r\n 1:GPIO Blink\r\n 2:LCD \n\r 3:7-Segment\n\r 4:RTC\n\r 5:EEPROM\n\r 6:ADC\n\r 7:Keypad \n\r Enter option:");
   1010 90s00r00           3716 	mov	dptr,#__str_0
   1013 75 F0 80           3717 	mov	b,#0x80
   1016 12s00r95           3718 	lcall	_UART_TxString
                           3719 ;	D:\Workspace\MIDE\firmware\main.c:54: UART_TxString("\n\rReset the board after test is done");
   1019 90s00r77           3720 	mov	dptr,#__str_1
   101C 75 F0 80           3721 	mov	b,#0x80
   101F 12s00r95           3722 	lcall	_UART_TxString
                           3723 ;	D:\Workspace\MIDE\firmware\main.c:55: mm_option = UART_RxChar();
   1022 12s00r83           3724 	lcall	_UART_RxChar
   1025 85 82*0A           3725 	mov	_mm_option,dpl
                           3726 ;	D:\Workspace\MIDE\firmware\main.c:56: while(1)
   1028                    3727 00111$:
                           3728 ;	D:\Workspace\MIDE\firmware\main.c:58: switch(mm_option)
   1028 C3                 3729 	clr	c
   1029 E5*0A              3730 	mov	a,_mm_option
   102B 64 80              3731 	xrl	a,#0x80
   102D 94 B1              3732 	subb	a,#0xb1
   102F 40 F7              3733 	jc	00111$
   1031 74 B7              3734 	mov	a,#(0x37 ^ 0x80)
   1033 85*0A F0           3735 	mov	b,_mm_option
   1036 63 F0 80           3736 	xrl	b,#0x80
   1039 95 F0              3737 	subb	a,b
   103B 40 EB              3738 	jc	00111$
   103D E5*0A              3739 	mov	a,_mm_option
   103F 24 CF              3740 	add	a,#0xcf
   1041 FA                 3741 	mov	r2,a
   1042 25 E0              3742 	add	a,acc
   1044 2A                 3743 	add	a,r2
   1045 90s10r49           3744 	mov	dptr,#00120$
   1048 73                 3745 	jmp	@a+dptr
   1049                    3746 00120$:
   1049 02s10r5E           3747 	ljmp	00101$
   104C 02s10r63           3748 	ljmp	00102$
   104F 02s10r68           3749 	ljmp	00103$
   1052 02s10r6D           3750 	ljmp	00104$
   1055 02s10r72           3751 	ljmp	00105$
   1058 02s10r77           3752 	ljmp	00106$
   105B 02s10r7C           3753 	ljmp	00107$
                           3754 ;	D:\Workspace\MIDE\firmware\main.c:60: case '1': gpio_test(); break;
   105E                    3755 00101$:
   105E 12s10r81           3756 	lcall	_gpio_test
                           3757 ;	D:\Workspace\MIDE\firmware\main.c:62: case '2': LCD_test(); break;
   1061 80 C5              3758 	sjmp	00111$
   1063                    3759 00102$:
   1063 12s10rD9           3760 	lcall	_LCD_test
                           3761 ;	D:\Workspace\MIDE\firmware\main.c:64: case '3': seg_test(); break;
   1066 80 C0              3762 	sjmp	00111$
   1068                    3763 00103$:
   1068 12s11r22           3764 	lcall	_seg_test
                           3765 ;	D:\Workspace\MIDE\firmware\main.c:66: case '4': rtc_test(); break; 
   106B 80 BB              3766 	sjmp	00111$
   106D                    3767 00104$:
   106D 12s12r09           3768 	lcall	_rtc_test
                           3769 ;	D:\Workspace\MIDE\firmware\main.c:68: case '5': eeprom_test(); break; //eeprom
   1070 80 B6              3770 	sjmp	00111$
   1072                    3771 00105$:
   1072 12s13r8E           3772 	lcall	_eeprom_test
                           3773 ;	D:\Workspace\MIDE\firmware\main.c:70: case '6': adc_test(); break;
   1075 80 B1              3774 	sjmp	00111$
   1077                    3775 00106$:
   1077 12s13rED           3776 	lcall	_adc_test
                           3777 ;	D:\Workspace\MIDE\firmware\main.c:72: case '7': keypad_test();break;
   107A 80 AC              3778 	sjmp	00111$
   107C                    3779 00107$:
   107C 12s14r73           3780 	lcall	_keypad_test
                           3781 ;	D:\Workspace\MIDE\firmware\main.c:77: }
   107F 80 A7              3782 	sjmp	00111$
                           3783 ;------------------------------------------------------------
                           3784 ;Allocation info for local variables in function 'gpio_test'
                           3785 ;------------------------------------------------------------
                           3786 ;------------------------------------------------------------
                           3787 ;	D:\Workspace\MIDE\firmware\main.c:82: void gpio_test()
                           3788 ;	-----------------------------------------
                           3789 ;	 function gpio_test
                           3790 ;	-----------------------------------------
   1081                    3791 _gpio_test:
                           3792 ;	D:\Workspace\MIDE\firmware\main.c:84: UART_Printf("\n\rConnect any IO Pins to buzzer, relays, leds ");
   1081 74r9C              3793 	mov	a,#__str_2
   1083 C0 E0              3794 	push	acc
   1085 74s00              3795 	mov	a,#(__str_2 >> 8)
   1087 C0 E0              3796 	push	acc
   1089 74 80              3797 	mov	a,#0x80
   108B C0 E0              3798 	push	acc
   108D 12s03r34           3799 	lcall	_UART_Printf
   1090 15 81              3800 	dec	sp
   1092 15 81              3801 	dec	sp
   1094 15 81              3802 	dec	sp
                           3803 ;	D:\Workspace\MIDE\firmware\main.c:85: UART_Printf("\n\rMake connections and hit 'k' to test ");
   1096 74rCB              3804 	mov	a,#__str_3
   1098 C0 E0              3805 	push	acc
   109A 74s00              3806 	mov	a,#(__str_3 >> 8)
   109C C0 E0              3807 	push	acc
   109E 74 80              3808 	mov	a,#0x80
   10A0 C0 E0              3809 	push	acc
   10A2 12s03r34           3810 	lcall	_UART_Printf
   10A5 15 81              3811 	dec	sp
   10A7 15 81              3812 	dec	sp
   10A9 15 81              3813 	dec	sp
                           3814 ;	D:\Workspace\MIDE\firmware\main.c:86: while(UART_RxChar()!='k');
   10AB                    3815 00101$:
   10AB 12s00r83           3816 	lcall	_UART_RxChar
   10AE AA 82              3817 	mov	r2,dpl
   10B0 BA 6B F8           3818 	cjne	r2,#0x6B,00101$
                           3819 ;	D:\Workspace\MIDE\firmware\main.c:87: while(1)
   10B3                    3820 00105$:
                           3821 ;	D:\Workspace\MIDE\firmware\main.c:90: P0= P1 = P2 =P3= 0xff;	   
   10B3 75 B0 FF           3822 	mov	_P3,#0xFF
   10B6 75 A0 FF           3823 	mov	_P2,#0xFF
   10B9 75 90 FF           3824 	mov	_P1,#0xFF
   10BC 75 80 FF           3825 	mov	_P0,#0xFF
                           3826 ;	D:\Workspace\MIDE\firmware\main.c:91: DELAY_sec(1);
   10BF 90 00 01           3827 	mov	dptr,#0x0001
   10C2 12s0CrF7           3828 	lcall	_DELAY_sec
                           3829 ;	D:\Workspace\MIDE\firmware\main.c:93: P0= P1 = P2 =P3= 0x00;;
   10C5 75 B0 00           3830 	mov	_P3,#0x00
   10C8 75 A0 00           3831 	mov	_P2,#0x00
   10CB 75 90 00           3832 	mov	_P1,#0x00
   10CE 75 80 00           3833 	mov	_P0,#0x00
                           3834 ;	D:\Workspace\MIDE\firmware\main.c:94: DELAY_sec(1);
   10D1 90 00 01           3835 	mov	dptr,#0x0001
   10D4 12s0CrF7           3836 	lcall	_DELAY_sec
   10D7 80 DA              3837 	sjmp	00105$
                           3838 ;------------------------------------------------------------
                           3839 ;Allocation info for local variables in function 'LCD_test'
                           3840 ;------------------------------------------------------------
                           3841 ;------------------------------------------------------------
                           3842 ;	D:\Workspace\MIDE\firmware\main.c:99: void LCD_test()
                           3843 ;	-----------------------------------------
                           3844 ;	 function LCD_test
                           3845 ;	-----------------------------------------
   10D9                    3846 _LCD_test:
                           3847 ;	D:\Workspace\MIDE\firmware\main.c:101: UART_TxString("\n\r LCD DataBus: P2 Control: RS-P0.0 RW-P0.1 E-P0.2 ");
   10D9 90s00rF3           3848 	mov	dptr,#__str_4
   10DC 75 F0 80           3849 	mov	b,#0x80
   10DF 12s00r95           3850 	lcall	_UART_TxString
                           3851 ;	D:\Workspace\MIDE\firmware\main.c:102: UART_Printf("\n\r Make connections and hit 'k' to test ");
   10E2 74r27              3852 	mov	a,#__str_5
   10E4 C0 E0              3853 	push	acc
   10E6 74s01              3854 	mov	a,#(__str_5 >> 8)
   10E8 C0 E0              3855 	push	acc
   10EA 74 80              3856 	mov	a,#0x80
   10EC C0 E0              3857 	push	acc
   10EE 12s03r34           3858 	lcall	_UART_Printf
   10F1 15 81              3859 	dec	sp
   10F3 15 81              3860 	dec	sp
   10F5 15 81              3861 	dec	sp
                           3862 ;	D:\Workspace\MIDE\firmware\main.c:103: while(UART_RxChar()!='k');
   10F7                    3863 00101$:
   10F7 12s00r83           3864 	lcall	_UART_RxChar
   10FA AA 82              3865 	mov	r2,dpl
   10FC BA 6B F8           3866 	cjne	r2,#0x6B,00101$
                           3867 ;	D:\Workspace\MIDE\firmware\main.c:104: LCD_Init(8,2,16);
   10FF 74 10              3868 	mov	a,#0x10
   1101 C0 E0              3869 	push	acc
   1103 74 02              3870 	mov	a,#0x02
   1105 C0 E0              3871 	push	acc
   1107 75 82 08           3872 	mov	dpl,#0x08
   110A 12s0Ar7E           3873 	lcall	_LCD_Init
   110D 15 81              3874 	dec	sp
   110F 15 81              3875 	dec	sp
                           3876 ;	D:\Workspace\MIDE\firmware\main.c:105: DELAY_ms(100);
   1111 90 00 64           3877 	mov	dptr,#0x0064
   1114 12s0CrD9           3878 	lcall	_DELAY_ms
                           3879 ;	D:\Workspace\MIDE\firmware\main.c:106: LCD_DisplayString("Explore Embedded!");
   1117 90s01r50           3880 	mov	dptr,#__str_6
   111A 75 F0 80           3881 	mov	b,#0x80
   111D 12s0Br81           3882 	lcall	_LCD_DisplayString
                           3883 ;	D:\Workspace\MIDE\firmware\main.c:107: while(1);
   1120                    3884 00105$:
   1120 80 FE              3885 	sjmp	00105$
                           3886 ;------------------------------------------------------------
                           3887 ;Allocation info for local variables in function 'seg_test'
                           3888 ;------------------------------------------------------------
                           3889 ;seg_code                  Allocated to stack - offset 1
                           3890 ;------------------------------------------------------------
                           3891 ;	D:\Workspace\MIDE\firmware\main.c:109: void seg_test()
                           3892 ;	-----------------------------------------
                           3893 ;	 function seg_test
                           3894 ;	-----------------------------------------
   1122                    3895 _seg_test:
   1122 C0*00              3896 	push	_bp
   1124 E5 81              3897 	mov	a,sp
   1126 F5*00              3898 	mov	_bp,a
   1128 24 04              3899 	add	a,#0x04
   112A F5 81              3900 	mov	sp,a
                           3901 ;	D:\Workspace\MIDE\firmware\main.c:111: unsigned char seg_code[]={0xC0,0xF9,0xA4,0xB0}; 
   112C A8*00              3902 	mov	r0,_bp
   112E 08                 3903 	inc	r0
   112F 76 C0              3904 	mov	@r0,#0xC0
   1131 E8                 3905 	mov	a,r0
   1132 04                 3906 	inc	a
   1133 F9                 3907 	mov	r1,a
   1134 77 F9              3908 	mov	@r1,#0xF9
   1136 74 02              3909 	mov	a,#0x02
   1138 28                 3910 	add	a,r0
   1139 FA                 3911 	mov	r2,a
   113A C0 00              3912 	push	ar0
   113C A8 02              3913 	mov	r0,ar2
   113E 76 A4              3914 	mov	@r0,#0xA4
   1140 D0 00              3915 	pop	ar0
   1142 74 03              3916 	mov	a,#0x03
   1144 28                 3917 	add	a,r0
   1145 FB                 3918 	mov	r3,a
   1146 C0 00              3919 	push	ar0
   1148 A8 03              3920 	mov	r0,ar3
   114A 76 B0              3921 	mov	@r0,#0xB0
   114C D0 00              3922 	pop	ar0
                           3923 ;	D:\Workspace\MIDE\firmware\main.c:112: UART_TxString("\n\r Segment DataBus: P2 Seg select: S1->P0.0 S2->P0.1 S3->P0.2 S4->P0.4  ");
   114E 90s01r62           3924 	mov	dptr,#__str_7
   1151 75 F0 80           3925 	mov	b,#0x80
   1154 C0 02              3926 	push	ar2
   1156 C0 03              3927 	push	ar3
   1158 C0 00              3928 	push	ar0
   115A C0 01              3929 	push	ar1
   115C 12s00r95           3930 	lcall	_UART_TxString
                           3931 ;	D:\Workspace\MIDE\firmware\main.c:113: UART_Printf("\n\rMake connections and hit 'k' to test! ");
   115F 74rAB              3932 	mov	a,#__str_8
   1161 C0 E0              3933 	push	acc
   1163 74s01              3934 	mov	a,#(__str_8 >> 8)
   1165 C0 E0              3935 	push	acc
   1167 74 80              3936 	mov	a,#0x80
   1169 C0 E0              3937 	push	acc
   116B 12s03r34           3938 	lcall	_UART_Printf
   116E 15 81              3939 	dec	sp
   1170 15 81              3940 	dec	sp
   1172 15 81              3941 	dec	sp
   1174 D0 01              3942 	pop	ar1
   1176 D0 00              3943 	pop	ar0
   1178 D0 03              3944 	pop	ar3
   117A D0 02              3945 	pop	ar2
                           3946 ;	D:\Workspace\MIDE\firmware\main.c:114: while(UART_RxChar()!='k');
   117C                    3947 00101$:
   117C C0 02              3948 	push	ar2
   117E C0 03              3949 	push	ar3
   1180 C0 00              3950 	push	ar0
   1182 C0 01              3951 	push	ar1
   1184 12s00r83           3952 	lcall	_UART_RxChar
   1187 AC 82              3953 	mov	r4,dpl
   1189 D0 01              3954 	pop	ar1
   118B D0 00              3955 	pop	ar0
   118D D0 03              3956 	pop	ar3
   118F D0 02              3957 	pop	ar2
   1191 BC 6B E8           3958 	cjne	r4,#0x6B,00101$
                           3959 ;	D:\Workspace\MIDE\firmware\main.c:115: while(1)
   1194                    3960 00105$:
                           3961 ;	D:\Workspace\MIDE\firmware\main.c:117: SegmentSlection=SegOne;
   1194 75 80 01           3962 	mov	_P0,#0x01
                           3963 ;	D:\Workspace\MIDE\firmware\main.c:118: SegmentValue = seg_code[0];
   1197 86 A0              3964 	mov	_P2,@r0
                           3965 ;	D:\Workspace\MIDE\firmware\main.c:119: DELAY_us(10); 
   1199 90 00 0A           3966 	mov	dptr,#0x000A
   119C C0 02              3967 	push	ar2
   119E C0 03              3968 	push	ar3
   11A0 C0 00              3969 	push	ar0
   11A2 C0 01              3970 	push	ar1
   11A4 12s0CrC9           3971 	lcall	_DELAY_us
   11A7 D0 01              3972 	pop	ar1
                           3973 ;	D:\Workspace\MIDE\firmware\main.c:120: SegmentSlection=SegTwo;
   11A9 75 80 02           3974 	mov	_P0,#0x02
                           3975 ;	D:\Workspace\MIDE\firmware\main.c:121: SegmentValue = seg_code[1];
   11AC 87 A0              3976 	mov	_P2,@r1
                           3977 ;	D:\Workspace\MIDE\firmware\main.c:122: DELAY_us(10);
   11AE 90 00 0A           3978 	mov	dptr,#0x000A
   11B1 C0 01              3979 	push	ar1
   11B3 12s0CrC9           3980 	lcall	_DELAY_us
   11B6 D0 01              3981 	pop	ar1
   11B8 D0 00              3982 	pop	ar0
   11BA D0 03              3983 	pop	ar3
   11BC D0 02              3984 	pop	ar2
                           3985 ;	D:\Workspace\MIDE\firmware\main.c:123: SegmentSlection=SegThree;
   11BE 75 80 04           3986 	mov	_P0,#0x04
                           3987 ;	D:\Workspace\MIDE\firmware\main.c:124: SegmentValue = seg_code[2];
   11C1 C0 00              3988 	push	ar0
   11C3 A8 02              3989 	mov	r0,ar2
   11C5 86 A0              3990 	mov	_P2,@r0
   11C7 D0 00              3991 	pop	ar0
                           3992 ;	D:\Workspace\MIDE\firmware\main.c:125: DELAY_us(10);	
   11C9 90 00 0A           3993 	mov	dptr,#0x000A
   11CC C0 02              3994 	push	ar2
   11CE C0 03              3995 	push	ar3
   11D0 C0 00              3996 	push	ar0
   11D2 C0 01              3997 	push	ar1
   11D4 12s0CrC9           3998 	lcall	_DELAY_us
   11D7 D0 01              3999 	pop	ar1
   11D9 D0 00              4000 	pop	ar0
   11DB D0 03              4001 	pop	ar3
   11DD D0 02              4002 	pop	ar2
                           4003 ;	D:\Workspace\MIDE\firmware\main.c:126: SegmentSlection=SegFour;  
   11DF 75 80 08           4004 	mov	_P0,#0x08
                           4005 ;	D:\Workspace\MIDE\firmware\main.c:127: SegmentValue = seg_code[3];
   11E2 C0 00              4006 	push	ar0
   11E4 A8 03              4007 	mov	r0,ar3
   11E6 86 A0              4008 	mov	_P2,@r0
   11E8 D0 00              4009 	pop	ar0
                           4010 ;	D:\Workspace\MIDE\firmware\main.c:128: DELAY_us(10);
   11EA 90 00 0A           4011 	mov	dptr,#0x000A
   11ED C0 02              4012 	push	ar2
   11EF C0 03              4013 	push	ar3
   11F1 C0 00              4014 	push	ar0
   11F3 C0 01              4015 	push	ar1
   11F5 12s0CrC9           4016 	lcall	_DELAY_us
   11F8 D0 01              4017 	pop	ar1
   11FA D0 00              4018 	pop	ar0
   11FC D0 03              4019 	pop	ar3
   11FE D0 02              4020 	pop	ar2
   1200 02s11r94           4021 	ljmp	00105$
   1203 85*00 81           4022 	mov	sp,_bp
   1206 D0*00              4023 	pop	_bp
   1208 22                 4024 	ret
                           4025 ;------------------------------------------------------------
                           4026 ;Allocation info for local variables in function 'rtc_test'
                           4027 ;------------------------------------------------------------
                           4028 ;sec                       Allocated to stack - offset 1
                           4029 ;min                       Allocated to stack - offset 2
                           4030 ;hour                      Allocated to stack - offset 3
                           4031 ;day                       Allocated to stack - offset 4
                           4032 ;month                     Allocated to stack - offset 5
                           4033 ;year                      Allocated to stack - offset 6
                           4034 ;sloc0                     Allocated to stack - offset 7
                           4035 ;sloc1                     Allocated to stack - offset 10
                           4036 ;sloc2                     Allocated to stack - offset 12
                           4037 ;------------------------------------------------------------
                           4038 ;	D:\Workspace\MIDE\firmware\main.c:132: void rtc_test()
                           4039 ;	-----------------------------------------
                           4040 ;	 function rtc_test
                           4041 ;	-----------------------------------------
   1209                    4042 _rtc_test:
   1209 C0*00              4043 	push	_bp
   120B E5 81              4044 	mov	a,sp
   120D F5*00              4045 	mov	_bp,a
   120F 24 0D              4046 	add	a,#0x0d
   1211 F5 81              4047 	mov	sp,a
                           4048 ;	D:\Workspace\MIDE\firmware\main.c:135: UART_Printf("\n\rConnections SCL->P0.6 SDA->P0.7");
   1213 74rD4              4049 	mov	a,#__str_9
   1215 C0 E0              4050 	push	acc
   1217 74s01              4051 	mov	a,#(__str_9 >> 8)
   1219 C0 E0              4052 	push	acc
   121B 74 80              4053 	mov	a,#0x80
   121D C0 E0              4054 	push	acc
   121F 12s03r34           4055 	lcall	_UART_Printf
   1222 15 81              4056 	dec	sp
   1224 15 81              4057 	dec	sp
   1226 15 81              4058 	dec	sp
                           4059 ;	D:\Workspace\MIDE\firmware\main.c:136: UART_Printf("\n\r Make connections and hit 'k' to test! ");
   1228 74rF6              4060 	mov	a,#__str_10
   122A C0 E0              4061 	push	acc
   122C 74s01              4062 	mov	a,#(__str_10 >> 8)
   122E C0 E0              4063 	push	acc
   1230 74 80              4064 	mov	a,#0x80
   1232 C0 E0              4065 	push	acc
   1234 12s03r34           4066 	lcall	_UART_Printf
   1237 15 81              4067 	dec	sp
   1239 15 81              4068 	dec	sp
   123B 15 81              4069 	dec	sp
                           4070 ;	D:\Workspace\MIDE\firmware\main.c:137: while(UART_RxChar()!='k');   
   123D                    4071 00101$:
   123D 12s00r83           4072 	lcall	_UART_RxChar
   1240 AA 82              4073 	mov	r2,dpl
   1242 BA 6B F8           4074 	cjne	r2,#0x6B,00101$
                           4075 ;	D:\Workspace\MIDE\firmware\main.c:139: RTC_Init();
   1245 12s07rC1           4076 	lcall	_RTC_Init
                           4077 ;	D:\Workspace\MIDE\firmware\main.c:144: RTC_SetTime(0x10,0x40,0x00);  //  10:40:20 am
   1248 E4                 4078 	clr	a
   1249 C0 E0              4079 	push	acc
   124B 74 40              4080 	mov	a,#0x40
   124D C0 E0              4081 	push	acc
   124F 75 82 10           4082 	mov	dpl,#0x10
   1252 12s07rDC           4083 	lcall	_RTC_SetTime
   1255 15 81              4084 	dec	sp
   1257 15 81              4085 	dec	sp
                           4086 ;	D:\Workspace\MIDE\firmware\main.c:145: RTC_SetDate(0x01,0x01,0x15);  //  1st Jan 2015
   1259 74 15              4087 	mov	a,#0x15
   125B C0 E0              4088 	push	acc
   125D 74 01              4089 	mov	a,#0x01
   125F C0 E0              4090 	push	acc
   1261 75 82 01           4091 	mov	dpl,#0x01
   1264 12s08r15           4092 	lcall	_RTC_SetDate
   1267 15 81              4093 	dec	sp
   1269 15 81              4094 	dec	sp
                           4095 ;	D:\Workspace\MIDE\firmware\main.c:150: while(1)
   126B                    4096 00105$:
                           4097 ;	D:\Workspace\MIDE\firmware\main.c:153: RTC_GetTime(&hour,&min,&sec);      
   126B AA*00              4098 	mov	r2,_bp
   126D 0A                 4099 	inc	r2
   126E 7B 00              4100 	mov	r3,#0x00
   1270 7C 40              4101 	mov	r4,#0x40
   1272 E5*00              4102 	mov	a,_bp
   1274 24 02              4103 	add	a,#0x02
   1276 FD                 4104 	mov	r5,a
   1277 E5*00              4105 	mov	a,_bp
   1279 24 07              4106 	add	a,#0x07
   127B F8                 4107 	mov	r0,a
   127C A6 05              4108 	mov	@r0,ar5
   127E 08                 4109 	inc	r0
   127F 76 00              4110 	mov	@r0,#0x00
   1281 08                 4111 	inc	r0
   1282 76 40              4112 	mov	@r0,#0x40
   1284 E5*00              4113 	mov	a,_bp
   1286 24 03              4114 	add	a,#0x03
   1288 FD                 4115 	mov	r5,a
   1289 7E 00              4116 	mov	r6,#0x00
   128B 7F 40              4117 	mov	r7,#0x40
   128D C0 02              4118 	push	ar2
   128F C0 03              4119 	push	ar3
   1291 C0 04              4120 	push	ar4
   1293 E5*00              4121 	mov	a,_bp
   1295 24 07              4122 	add	a,#0x07
   1297 F8                 4123 	mov	r0,a
   1298 E6                 4124 	mov	a,@r0
   1299 C0 E0              4125 	push	acc
   129B 08                 4126 	inc	r0
   129C E6                 4127 	mov	a,@r0
   129D C0 E0              4128 	push	acc
   129F 08                 4129 	inc	r0
   12A0 E6                 4130 	mov	a,@r0
   12A1 C0 E0              4131 	push	acc
   12A3 8D 82              4132 	mov	dpl,r5
   12A5 8E 83              4133 	mov	dph,r6
   12A7 8F F0              4134 	mov	b,r7
   12A9 12s08r4E           4135 	lcall	_RTC_GetTime
   12AC E5 81              4136 	mov	a,sp
   12AE 24 FA              4137 	add	a,#0xfa
   12B0 F5 81              4138 	mov	sp,a
                           4139 ;	D:\Workspace\MIDE\firmware\main.c:154: RTC_GetDate(&day,&month,&year);        
   12B2 E5*00              4140 	mov	a,_bp
   12B4 24 06              4141 	add	a,#0x06
   12B6 FA                 4142 	mov	r2,a
   12B7 7B 00              4143 	mov	r3,#0x00
   12B9 7C 40              4144 	mov	r4,#0x40
   12BB E5*00              4145 	mov	a,_bp
   12BD 24 05              4146 	add	a,#0x05
   12BF FD                 4147 	mov	r5,a
   12C0 E5*00              4148 	mov	a,_bp
   12C2 24 07              4149 	add	a,#0x07
   12C4 F8                 4150 	mov	r0,a
   12C5 A6 05              4151 	mov	@r0,ar5
   12C7 08                 4152 	inc	r0
   12C8 76 00              4153 	mov	@r0,#0x00
   12CA 08                 4154 	inc	r0
   12CB 76 40              4155 	mov	@r0,#0x40
   12CD E5*00              4156 	mov	a,_bp
   12CF 24 04              4157 	add	a,#0x04
   12D1 FD                 4158 	mov	r5,a
   12D2 7E 00              4159 	mov	r6,#0x00
   12D4 7F 40              4160 	mov	r7,#0x40
   12D6 C0 02              4161 	push	ar2
   12D8 C0 03              4162 	push	ar3
   12DA C0 04              4163 	push	ar4
   12DC E5*00              4164 	mov	a,_bp
   12DE 24 07              4165 	add	a,#0x07
   12E0 F8                 4166 	mov	r0,a
   12E1 E6                 4167 	mov	a,@r0
   12E2 C0 E0              4168 	push	acc
   12E4 08                 4169 	inc	r0
   12E5 E6                 4170 	mov	a,@r0
   12E6 C0 E0              4171 	push	acc
   12E8 08                 4172 	inc	r0
   12E9 E6                 4173 	mov	a,@r0
   12EA C0 E0              4174 	push	acc
   12EC 8D 82              4175 	mov	dpl,r5
   12EE 8E 83              4176 	mov	dph,r6
   12F0 8F F0              4177 	mov	b,r7
   12F2 12s08rEA           4178 	lcall	_RTC_GetDate
   12F5 E5 81              4179 	mov	a,sp
   12F7 24 FA              4180 	add	a,#0xfa
   12F9 F5 81              4181 	mov	sp,a
                           4182 ;	D:\Workspace\MIDE\firmware\main.c:156: UART_Printf("\n\rtime:%2x:%2x:%2x  \nDate:%2x/%2x/%2x",(uint16_t)hour,(uint16_t)min,(uint16_t)sec,(uint16_t)day,(uint16_t)month,(uint16_t)year);
   12FB E5*00              4183 	mov	a,_bp
   12FD 24 06              4184 	add	a,#0x06
   12FF F8                 4185 	mov	r0,a
   1300 86 02              4186 	mov	ar2,@r0
   1302 7B 00              4187 	mov	r3,#0x00
   1304 E5*00              4188 	mov	a,_bp
   1306 24 05              4189 	add	a,#0x05
   1308 F8                 4190 	mov	r0,a
   1309 86 04              4191 	mov	ar4,@r0
   130B 7D 00              4192 	mov	r5,#0x00
   130D E5*00              4193 	mov	a,_bp
   130F 24 04              4194 	add	a,#0x04
   1311 F8                 4195 	mov	r0,a
   1312 E5*00              4196 	mov	a,_bp
   1314 24 07              4197 	add	a,#0x07
   1316 F9                 4198 	mov	r1,a
   1317 E6                 4199 	mov	a,@r0
   1318 F7                 4200 	mov	@r1,a
   1319 09                 4201 	inc	r1
   131A 77 00              4202 	mov	@r1,#0x00
   131C A8*00              4203 	mov	r0,_bp
   131E 08                 4204 	inc	r0
   131F E5*00              4205 	mov	a,_bp
   1321 24 0A              4206 	add	a,#0x0a
   1323 F9                 4207 	mov	r1,a
   1324 E6                 4208 	mov	a,@r0
   1325 F7                 4209 	mov	@r1,a
   1326 09                 4210 	inc	r1
   1327 77 00              4211 	mov	@r1,#0x00
   1329 A8*00              4212 	mov	r0,_bp
   132B 08                 4213 	inc	r0
   132C 08                 4214 	inc	r0
   132D E5*00              4215 	mov	a,_bp
   132F 24 0C              4216 	add	a,#0x0c
   1331 F9                 4217 	mov	r1,a
   1332 E6                 4218 	mov	a,@r0
   1333 F7                 4219 	mov	@r1,a
   1334 09                 4220 	inc	r1
   1335 77 00              4221 	mov	@r1,#0x00
   1337 E5*00              4222 	mov	a,_bp
   1339 24 03              4223 	add	a,#0x03
   133B F8                 4224 	mov	r0,a
   133C 86 06              4225 	mov	ar6,@r0
   133E 7F 00              4226 	mov	r7,#0x00
   1340 C0 02              4227 	push	ar2
   1342 C0 03              4228 	push	ar3
   1344 C0 04              4229 	push	ar4
   1346 C0 05              4230 	push	ar5
   1348 E5*00              4231 	mov	a,_bp
   134A 24 07              4232 	add	a,#0x07
   134C F8                 4233 	mov	r0,a
   134D E6                 4234 	mov	a,@r0
   134E C0 E0              4235 	push	acc
   1350 08                 4236 	inc	r0
   1351 E6                 4237 	mov	a,@r0
   1352 C0 E0              4238 	push	acc
   1354 E5*00              4239 	mov	a,_bp
   1356 24 0A              4240 	add	a,#0x0a
   1358 F8                 4241 	mov	r0,a
   1359 E6                 4242 	mov	a,@r0
   135A C0 E0              4243 	push	acc
   135C 08                 4244 	inc	r0
   135D E6                 4245 	mov	a,@r0
   135E C0 E0              4246 	push	acc
   1360 E5*00              4247 	mov	a,_bp
   1362 24 0C              4248 	add	a,#0x0c
   1364 F8                 4249 	mov	r0,a
   1365 E6                 4250 	mov	a,@r0
   1366 C0 E0              4251 	push	acc
   1368 08                 4252 	inc	r0
   1369 E6                 4253 	mov	a,@r0
   136A C0 E0              4254 	push	acc
   136C C0 06              4255 	push	ar6
   136E C0 07              4256 	push	ar7
   1370 74r20              4257 	mov	a,#__str_11
   1372 C0 E0              4258 	push	acc
   1374 74s02              4259 	mov	a,#(__str_11 >> 8)
   1376 C0 E0              4260 	push	acc
   1378 74 80              4261 	mov	a,#0x80
   137A C0 E0              4262 	push	acc
   137C 12s03r34           4263 	lcall	_UART_Printf
   137F E5 81              4264 	mov	a,sp
   1381 24 F1              4265 	add	a,#0xf1
   1383 F5 81              4266 	mov	sp,a
   1385 02s12r6B           4267 	ljmp	00105$
   1388 85*00 81           4268 	mov	sp,_bp
   138B D0*00              4269 	pop	_bp
   138D 22                 4270 	ret
                           4271 ;------------------------------------------------------------
                           4272 ;Allocation info for local variables in function 'eeprom_test'
                           4273 ;------------------------------------------------------------
                           4274 ;eeprom_address            Allocated to registers 
                           4275 ;write_char                Allocated to registers 
                           4276 ;read_char                 Allocated to registers r2 
                           4277 ;------------------------------------------------------------
                           4278 ;	D:\Workspace\MIDE\firmware\main.c:163: void eeprom_test()
                           4279 ;	-----------------------------------------
                           4280 ;	 function eeprom_test
                           4281 ;	-----------------------------------------
   138E                    4282 _eeprom_test:
                           4283 ;	D:\Workspace\MIDE\firmware\main.c:167: UART_Printf("Connections SCL->P0.6 SDA->P0.7");
   138E 74r46              4284 	mov	a,#__str_12
   1390 C0 E0              4285 	push	acc
   1392 74s02              4286 	mov	a,#(__str_12 >> 8)
   1394 C0 E0              4287 	push	acc
   1396 74 80              4288 	mov	a,#0x80
   1398 C0 E0              4289 	push	acc
   139A 12s03r34           4290 	lcall	_UART_Printf
   139D 15 81              4291 	dec	sp
   139F 15 81              4292 	dec	sp
   13A1 15 81              4293 	dec	sp
                           4294 ;	D:\Workspace\MIDE\firmware\main.c:168: UART_Printf("Make connections and hit 'k' to test! ");
   13A3 74r66              4295 	mov	a,#__str_13
   13A5 C0 E0              4296 	push	acc
   13A7 74s02              4297 	mov	a,#(__str_13 >> 8)
   13A9 C0 E0              4298 	push	acc
   13AB 74 80              4299 	mov	a,#0x80
   13AD C0 E0              4300 	push	acc
   13AF 12s03r34           4301 	lcall	_UART_Printf
   13B2 15 81              4302 	dec	sp
   13B4 15 81              4303 	dec	sp
   13B6 15 81              4304 	dec	sp
                           4305 ;	D:\Workspace\MIDE\firmware\main.c:169: while(UART_RxChar()!='k');
   13B8                    4306 00101$:
   13B8 12s00r83           4307 	lcall	_UART_RxChar
   13BB AA 82              4308 	mov	r2,dpl
   13BD BA 6B F8           4309 	cjne	r2,#0x6B,00101$
                           4310 ;	D:\Workspace\MIDE\firmware\main.c:170: UART_TxString("\n\rEeprom Write: ");      //Print the message on UART
   13C0 90s02r8D           4311 	mov	dptr,#__str_14
   13C3 75 F0 80           4312 	mov	b,#0x80
   13C6 12s00r95           4313 	lcall	_UART_TxString
                           4314 ;	D:\Workspace\MIDE\firmware\main.c:171: UART_TxChar(write_char);			         //Print the char to be written 
   13C9 75 82 58           4315 	mov	dpl,#0x58
   13CC 12s00r8C           4316 	lcall	_UART_TxChar
                           4317 ;	D:\Workspace\MIDE\firmware\main.c:172: EEPROM_WriteByte(eeprom_address,write_char);	// Write the data at memoryLocation	0x00
   13CF 74 58              4318 	mov	a,#0x58
   13D1 C0 E0              4319 	push	acc
   13D3 90 00 00           4320 	mov	dptr,#0x0000
   13D6 12s0ErB2           4321 	lcall	_EEPROM_WriteByte
   13D9 15 81              4322 	dec	sp
                           4323 ;	D:\Workspace\MIDE\firmware\main.c:174: UART_TxString("  Eeprom Read: ");            //Print the message on UART
   13DB 90s02r9E           4324 	mov	dptr,#__str_15
   13DE 75 F0 80           4325 	mov	b,#0x80
   13E1 12s00r95           4326 	lcall	_UART_TxString
                           4327 ;	D:\Workspace\MIDE\firmware\main.c:175: read_char = EEPROM_ReadByte(eeprom_address);	// Read the data from memoryLocation 0x00
   13E4 90 00 00           4328 	mov	dptr,#0x0000
   13E7 12s0ErF9           4329 	lcall	_EEPROM_ReadByte
                           4330 ;	D:\Workspace\MIDE\firmware\main.c:176: UART_TxChar(read_char);	
   13EA 02s00r8C           4331 	ljmp	_UART_TxChar
                           4332 ;------------------------------------------------------------
                           4333 ;Allocation info for local variables in function 'adc_test'
                           4334 ;------------------------------------------------------------
                           4335 ;temp                      Allocated to registers 
                           4336 ;light                     Allocated to registers 
                           4337 ;pot                       Allocated to registers 
                           4338 ;------------------------------------------------------------
                           4339 ;	D:\Workspace\MIDE\firmware\main.c:180: void adc_test()
                           4340 ;	-----------------------------------------
                           4341 ;	 function adc_test
                           4342 ;	-----------------------------------------
   13ED                    4343 _adc_test:
                           4344 ;	D:\Workspace\MIDE\firmware\main.c:183: UART_Printf("\n\rConnections: DataBus P1 Control: adc_A->P0.0 adc_B->P0.1 adc_C->P0.2 adc_ALE->P.3 adc_Start->P.4 adc_EOC->P1.5 adc_OE->P1.6");
   13ED 74rAE              4345 	mov	a,#__str_16
   13EF C0 E0              4346 	push	acc
   13F1 74s02              4347 	mov	a,#(__str_16 >> 8)
   13F3 C0 E0              4348 	push	acc
   13F5 74 80              4349 	mov	a,#0x80
   13F7 C0 E0              4350 	push	acc
   13F9 12s03r34           4351 	lcall	_UART_Printf
   13FC 15 81              4352 	dec	sp
   13FE 15 81              4353 	dec	sp
   1400 15 81              4354 	dec	sp
                           4355 ;	D:\Workspace\MIDE\firmware\main.c:184: UART_Printf("\n\rMake connections and hit 'k' to test!");
   1402 74r2C              4356 	mov	a,#__str_17
   1404 C0 E0              4357 	push	acc
   1406 74s03              4358 	mov	a,#(__str_17 >> 8)
   1408 C0 E0              4359 	push	acc
   140A 74 80              4360 	mov	a,#0x80
   140C C0 E0              4361 	push	acc
   140E 12s03r34           4362 	lcall	_UART_Printf
   1411 15 81              4363 	dec	sp
   1413 15 81              4364 	dec	sp
   1415 15 81              4365 	dec	sp
                           4366 ;	D:\Workspace\MIDE\firmware\main.c:185: while(UART_RxChar()!='k');
   1417                    4367 00101$:
   1417 12s00r83           4368 	lcall	_UART_RxChar
   141A AA 82              4369 	mov	r2,dpl
   141C BA 6B F8           4370 	cjne	r2,#0x6B,00101$
                           4371 ;	D:\Workspace\MIDE\firmware\main.c:186: ADC_Init();
   141F 12s0Dr15           4372 	lcall	_ADC_Init
                           4373 ;	D:\Workspace\MIDE\firmware\main.c:188: while(1)
   1422                    4374 00105$:
                           4375 ;	D:\Workspace\MIDE\firmware\main.c:190: temp = ADC_GetAdcValue(0);
   1422 75 82 00           4376 	mov	dpl,#0x00
   1425 12s0Dr25           4377 	lcall	_ADC_GetAdcValue
   1428 AA 82              4378 	mov	r2,dpl
   142A AB 83              4379 	mov	r3,dph
                           4380 ;	D:\Workspace\MIDE\firmware\main.c:191: pot = ADC_GetAdcValue(1);
   142C 75 82 01           4381 	mov	dpl,#0x01
   142F C0 02              4382 	push	ar2
   1431 C0 03              4383 	push	ar3
   1433 12s0Dr25           4384 	lcall	_ADC_GetAdcValue
   1436 AC 82              4385 	mov	r4,dpl
   1438 AD 83              4386 	mov	r5,dph
                           4387 ;	D:\Workspace\MIDE\firmware\main.c:192: light = ADC_GetAdcValue(2);
   143A 75 82 02           4388 	mov	dpl,#0x02
   143D C0 04              4389 	push	ar4
   143F C0 05              4390 	push	ar5
   1441 12s0Dr25           4391 	lcall	_ADC_GetAdcValue
   1444 AE 82              4392 	mov	r6,dpl
   1446 AF 83              4393 	mov	r7,dph
   1448 D0 05              4394 	pop	ar5
   144A D0 04              4395 	pop	ar4
   144C D0 03              4396 	pop	ar3
   144E D0 02              4397 	pop	ar2
                           4398 ;	D:\Workspace\MIDE\firmware\main.c:193: UART_Printf("\n\rtemp:%3d pot:%3d light:%3d", temp,pot,light);
   1450 C0 06              4399 	push	ar6
   1452 C0 07              4400 	push	ar7
   1454 C0 04              4401 	push	ar4
   1456 C0 05              4402 	push	ar5
   1458 C0 02              4403 	push	ar2
   145A C0 03              4404 	push	ar3
   145C 74r54              4405 	mov	a,#__str_18
   145E C0 E0              4406 	push	acc
   1460 74s03              4407 	mov	a,#(__str_18 >> 8)
   1462 C0 E0              4408 	push	acc
   1464 74 80              4409 	mov	a,#0x80
   1466 C0 E0              4410 	push	acc
   1468 12s03r34           4411 	lcall	_UART_Printf
   146B E5 81              4412 	mov	a,sp
   146D 24 F7              4413 	add	a,#0xf7
   146F F5 81              4414 	mov	sp,a
   1471 80 AF              4415 	sjmp	00105$
                           4416 ;------------------------------------------------------------
                           4417 ;Allocation info for local variables in function 'keypad_test'
                           4418 ;------------------------------------------------------------
                           4419 ;key                       Allocated to registers r2 
                           4420 ;------------------------------------------------------------
                           4421 ;	D:\Workspace\MIDE\firmware\main.c:198: void keypad_test()
                           4422 ;	-----------------------------------------
                           4423 ;	 function keypad_test
                           4424 ;	-----------------------------------------
   1473                    4425 _keypad_test:
                           4426 ;	D:\Workspace\MIDE\firmware\main.c:201: UART_Printf("\n\rConnections: Port 2");
   1473 74r71              4427 	mov	a,#__str_19
   1475 C0 E0              4428 	push	acc
   1477 74s03              4429 	mov	a,#(__str_19 >> 8)
   1479 C0 E0              4430 	push	acc
   147B 74 80              4431 	mov	a,#0x80
   147D C0 E0              4432 	push	acc
   147F 12s03r34           4433 	lcall	_UART_Printf
   1482 15 81              4434 	dec	sp
   1484 15 81              4435 	dec	sp
   1486 15 81              4436 	dec	sp
                           4437 ;	D:\Workspace\MIDE\firmware\main.c:202: UART_Printf("\n\rMake connections and hit 'k' to test!");
   1488 74r2C              4438 	mov	a,#__str_17
   148A C0 E0              4439 	push	acc
   148C 74s03              4440 	mov	a,#(__str_17 >> 8)
   148E C0 E0              4441 	push	acc
   1490 74 80              4442 	mov	a,#0x80
   1492 C0 E0              4443 	push	acc
   1494 12s03r34           4444 	lcall	_UART_Printf
   1497 15 81              4445 	dec	sp
   1499 15 81              4446 	dec	sp
   149B 15 81              4447 	dec	sp
                           4448 ;	D:\Workspace\MIDE\firmware\main.c:203: while(UART_RxChar()!='k');
   149D                    4449 00101$:
   149D 12s00r83           4450 	lcall	_UART_RxChar
   14A0 AA 82              4451 	mov	r2,dpl
   14A2 BA 6B F8           4452 	cjne	r2,#0x6B,00101$
                           4453 ;	D:\Workspace\MIDE\firmware\main.c:204: KEYPAD_Init();
   14A5 12s0Dr8D           4454 	lcall	_KEYPAD_Init
                           4455 ;	D:\Workspace\MIDE\firmware\main.c:205: while(1)
   14A8                    4456 00105$:
                           4457 ;	D:\Workspace\MIDE\firmware\main.c:207: key = KEYPAD_GetKey();
   14A8 12s0DrCB           4458 	lcall	_KEYPAD_GetKey
   14AB AA 82              4459 	mov	r2,dpl
                           4460 ;	D:\Workspace\MIDE\firmware\main.c:208: UART_Printf("\n\r Key:%c", key);
   14AD 7B 00              4461 	mov	r3,#0x00
   14AF C0 02              4462 	push	ar2
   14B1 C0 03              4463 	push	ar3
   14B3 74r87              4464 	mov	a,#__str_20
   14B5 C0 E0              4465 	push	acc
   14B7 74s03              4466 	mov	a,#(__str_20 >> 8)
   14B9 C0 E0              4467 	push	acc
   14BB 74 80              4468 	mov	a,#0x80
   14BD C0 E0              4469 	push	acc
   14BF 12s03r34           4470 	lcall	_UART_Printf
   14C2 E5 81              4471 	mov	a,sp
   14C4 24 FB              4472 	add	a,#0xfb
   14C6 F5 81              4473 	mov	sp,a
   14C8 80 DE              4474 	sjmp	00105$
                           4475 	.area CSEG    (CODE)
                           4476 	.area CONST   (CODE)
   0000                    4477 __str_0:
   0000 0A                 4478 	.db 0x0A
   0001 0D                 4479 	.db 0x0D
   0002 54 65 73 74 20 6D  4480 	.ascii "Test menu Utra x51 v1.1"
        65 6E 75 20 55 74
        72 61 20 78 35 31
        20 76 31 2E 31
   0019 0D                 4481 	.db 0x0D
   001A 0A                 4482 	.db 0x0A
   001B 20 31 3A 47 50 49  4483 	.ascii " 1:GPIO Blink"
        4F 20 42 6C 69 6E
        6B
   0028 0D                 4484 	.db 0x0D
   0029 0A                 4485 	.db 0x0A
   002A 20 32 3A 4C 43 44  4486 	.ascii " 2:LCD "
        20
   0031 0A                 4487 	.db 0x0A
   0032 0D                 4488 	.db 0x0D
   0033 20 33 3A 37 2D 53  4489 	.ascii " 3:7-Segm"
        65 67 6D
   003C 65 6E 74           4490 	.ascii "ent"
   003F 0A                 4491 	.db 0x0A
   0040 0D                 4492 	.db 0x0D
   0041 20 34 3A 52 54 43  4493 	.ascii " 4:RTC"
   0047 0A                 4494 	.db 0x0A
   0048 0D                 4495 	.db 0x0D
   0049 20 35 3A 45 45 50  4496 	.ascii " 5:EEPROM"
        52 4F 4D
   0052 0A                 4497 	.db 0x0A
   0053 0D                 4498 	.db 0x0D
   0054 20 36 3A 41 44 43  4499 	.ascii " 6:ADC"
   005A 0A                 4500 	.db 0x0A
   005B 0D                 4501 	.db 0x0D
   005C 20 37 3A 4B 65 79  4502 	.ascii " 7:Keypad "
        70 61 64 20
   0066 0A                 4503 	.db 0x0A
   0067 0D                 4504 	.db 0x0D
   0068 20 45 6E 74 65 72  4505 	.ascii " Enter option:"
        20 6F 70 74 69 6F
        6E 3A
   0076 00                 4506 	.db 0x00
   0077                    4507 __str_1:
   0077 0A                 4508 	.db 0x0A
   0078 0D                 4509 	.db 0x0D
   0079 52 65 73 65 74 20  4510 	.ascii "Reset the board after test is done"
        74 68 65 20 62 6F
        61 72 64 20 61 66
        74 65 72 20 74 65
        73 74 20 69 73 20
        64 6F 6E 65
   009B 00                 4511 	.db 0x00
   009C                    4512 __str_2:
   009C 0A                 4513 	.db 0x0A
   009D 0D                 4514 	.db 0x0D
   009E 43 6F 6E 6E 65 63  4515 	.ascii "Connect any IO Pins to buzzer, relays, leds "
        74 20 61 6E 79 20
        49 4F 20 50 69 6E
        73 20 74 6F 20 62
        75 7A 7A 65 72 2C
        20 72 65 6C 61 79
        73 2C 20 6C 65 64
        73 20
   00CA 00                 4516 	.db 0x00
   00CB                    4517 __str_3:
   00CB 0A                 4518 	.db 0x0A
   00CC 0D                 4519 	.db 0x0D
   00CD 4D 61 6B 65 20 63  4520 	.ascii "Make connections and hit 'k' to test "
        6F 6E 6E 65 63 74
        69 6F 6E 73 20 61
        6E 64 20 68 69 74
        20 27 6B 27 20 74
        6F 20 74 65 73 74
        20
   00F2 00                 4521 	.db 0x00
   00F3                    4522 __str_4:
   00F3 0A                 4523 	.db 0x0A
   00F4 0D                 4524 	.db 0x0D
   00F5 20 4C 43 44 20 44  4525 	.ascii " LCD DataBus: P2 Control: RS-P0.0 RW-P0.1 E-P0.2 "
        61 74 61 42 75 73
        3A 20 50 32 20 43
        6F 6E 74 72 6F 6C
        3A 20 52 53 2D 50
        30 2E 30 20 52 57
        2D 50 30 2E 31 20
        45 2D 50 30 2E 32
        20
   0126 00                 4526 	.db 0x00
   0127                    4527 __str_5:
   0127 0A                 4528 	.db 0x0A
   0128 0D                 4529 	.db 0x0D
   0129 20 4D 61 6B 65 20  4530 	.ascii " Make connections and hit 'k' to test "
        63 6F 6E 6E 65 63
        74 69 6F 6E 73 20
        61 6E 64 20 68 69
        74 20 27 6B 27 20
        74 6F 20 74 65 73
        74 20
   014F 00                 4531 	.db 0x00
   0150                    4532 __str_6:
   0150 45 78 70 6C 6F 72  4533 	.ascii "Explore Embedded!"
        65 20 45 6D 62 65
        64 64 65 64 21
   0161 00                 4534 	.db 0x00
   0162                    4535 __str_7:
   0162 0A                 4536 	.db 0x0A
   0163 0D                 4537 	.db 0x0D
   0164 20 53 65 67 6D 65  4538 	.ascii " Segment DataBus: P2 Seg select: S1->P0.0 S2->P0.1 S3->P0."
        6E 74 20 44 61 74
        61 42 75 73 3A 20
        50 32 20 53 65 67
        20 73 65 6C 65 63
        74 3A 20 53 31 2D
        3E 50 30 2E 30 20
        53 32 2D 3E 50 30
        2E 31 20 53 33 2D
        3E 50 30 2E
   019E 32 20 53 34 2D 3E  4539 	.ascii "2 S4->P0.4  "
        50 30 2E 34 20 20
   01AA 00                 4540 	.db 0x00
   01AB                    4541 __str_8:
   01AB 0A                 4542 	.db 0x0A
   01AC 0D                 4543 	.db 0x0D
   01AD 4D 61 6B 65 20 63  4544 	.ascii "Make connections and hit 'k' to test! "
        6F 6E 6E 65 63 74
        69 6F 6E 73 20 61
        6E 64 20 68 69 74
        20 27 6B 27 20 74
        6F 20 74 65 73 74
        21 20
   01D3 00                 4545 	.db 0x00
   01D4                    4546 __str_9:
   01D4 0A                 4547 	.db 0x0A
   01D5 0D                 4548 	.db 0x0D
   01D6 43 6F 6E 6E 65 63  4549 	.ascii "Connections SCL->P0.6 SDA->P0.7"
        74 69 6F 6E 73 20
        53 43 4C 2D 3E 50
        30 2E 36 20 53 44
        41 2D 3E 50 30 2E
        37
   01F5 00                 4550 	.db 0x00
   01F6                    4551 __str_10:
   01F6 0A                 4552 	.db 0x0A
   01F7 0D                 4553 	.db 0x0D
   01F8 20 4D 61 6B 65 20  4554 	.ascii " Make connections and hit 'k' to test! "
        63 6F 6E 6E 65 63
        74 69 6F 6E 73 20
        61 6E 64 20 68 69
        74 20 27 6B 27 20
        74 6F 20 74 65 73
        74 21 20
   021F 00                 4555 	.db 0x00
   0220                    4556 __str_11:
   0220 0A                 4557 	.db 0x0A
   0221 0D                 4558 	.db 0x0D
   0222 74 69 6D 65 3A 25  4559 	.ascii "time:%2x:%2x:%2x  "
        32 78 3A 25 32 78
        3A 25 32 78 20 20
   0234 0A                 4560 	.db 0x0A
   0235 44 61 74 65 3A 25  4561 	.ascii "Date:%2x/%2x/%2x"
        32 78 2F 25 32 78
        2F 25 32 78
   0245 00                 4562 	.db 0x00
   0246                    4563 __str_12:
   0246 43 6F 6E 6E 65 63  4564 	.ascii "Connections SCL->P0.6 SDA->P0.7"
        74 69 6F 6E 73 20
        53 43 4C 2D 3E 50
        30 2E 36 20 53 44
        41 2D 3E 50 30 2E
        37
   0265 00                 4565 	.db 0x00
   0266                    4566 __str_13:
   0266 4D 61 6B 65 20 63  4567 	.ascii "Make connections and hit 'k' to test! "
        6F 6E 6E 65 63 74
        69 6F 6E 73 20 61
        6E 64 20 68 69 74
        20 27 6B 27 20 74
        6F 20 74 65 73 74
        21 20
   028C 00                 4568 	.db 0x00
   028D                    4569 __str_14:
   028D 0A                 4570 	.db 0x0A
   028E 0D                 4571 	.db 0x0D
   028F 45 65 70 72 6F 6D  4572 	.ascii "Eeprom Write: "
        20 57 72 69 74 65
        3A 20
   029D 00                 4573 	.db 0x00
   029E                    4574 __str_15:
   029E 20 20 45 65 70 72  4575 	.ascii "  Eeprom Read: "
        6F 6D 20 52 65 61
        64 3A 20
   02AD 00                 4576 	.db 0x00
   02AE                    4577 __str_16:
   02AE 0A                 4578 	.db 0x0A
   02AF 0D                 4579 	.db 0x0D
   02B0 43 6F 6E 6E 65 63  4580 	.ascii "Connections: DataBus P1 Control: adc_A->P0.0 adc_B->P0.1 a"
        74 69 6F 6E 73 3A
        20 44 61 74 61 42
        75 73 20 50 31 20
        43 6F 6E 74 72 6F
        6C 3A 20 61 64 63
        5F 41 2D 3E 50 30
        2E 30 20 61 64 63
        5F 42 2D 3E 50 30
        2E 31 20 61
   02EA 64 63 5F 43 2D 3E  4581 	.ascii "dc_C->P0.2 adc_ALE->P.3 adc_Start->P.4 adc_EOC->P1.5 adc_OE-"
        50 30 2E 32 20 61
        64 63 5F 41 4C 45
        2D 3E 50 2E 33 20
        61 64 63 5F 53 74
        61 72 74 2D 3E 50
        2E 34 20 61 64 63
        5F 45 4F 43 2D 3E
        50 31 2E 35 20 61
        64 63 5F 4F 45 2D
   0326 3E 50 31 2E 36     4582 	.ascii ">P1.6"
   032B 00                 4583 	.db 0x00
   032C                    4584 __str_17:
   032C 0A                 4585 	.db 0x0A
   032D 0D                 4586 	.db 0x0D
   032E 4D 61 6B 65 20 63  4587 	.ascii "Make connections and hit 'k' to test!"
        6F 6E 6E 65 63 74
        69 6F 6E 73 20 61
        6E 64 20 68 69 74
        20 27 6B 27 20 74
        6F 20 74 65 73 74
        21
   0353 00                 4588 	.db 0x00
   0354                    4589 __str_18:
   0354 0A                 4590 	.db 0x0A
   0355 0D                 4591 	.db 0x0D
   0356 74 65 6D 70 3A 25  4592 	.ascii "temp:%3d pot:%3d light:%3d"
        33 64 20 70 6F 74
        3A 25 33 64 20 6C
        69 67 68 74 3A 25
        33 64
   0370 00                 4593 	.db 0x00
   0371                    4594 __str_19:
   0371 0A                 4595 	.db 0x0A
   0372 0D                 4596 	.db 0x0D
   0373 43 6F 6E 6E 65 63  4597 	.ascii "Connections: Port 2"
        74 69 6F 6E 73 3A
        20 50 6F 72 74 20
        32
   0386 00                 4598 	.db 0x00
   0387                    4599 __str_20:
   0387 0A                 4600 	.db 0x0A
   0388 0D                 4601 	.db 0x0D
   0389 20 4B 65 79 3A 25  4602 	.ascii " Key:%c"
        63
   0390 00                 4603 	.db 0x00
                           4604 	.area XINIT   (CODE)
                           4605 	.area CABS    (ABS,CODE)
